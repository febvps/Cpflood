<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 850px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #667eea;
        }

        h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #a0a0ff;
            border-bottom: 1px solid #3a3a5a;
            padding-bottom: 8px;
        }

        .section {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a5a;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.95rem;
        }

        input[type="number"] {
            width: 150px;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            line-height: 1.5;
        }

        textarea#inputMessages {
            min-height: 150px;
            font-size: 0.95rem;
        }

        select {
            cursor: pointer;
        }

        select option {
            padding: 8px;
            background: #1a1a2e;
        }

        .hint {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #ccc;
        }

        .radio-label input[type="radio"] {
            width: auto;
            cursor: pointer;
        }

        .room-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .room-list-header label {
            margin-bottom: 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #ccc;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4a4a6a;
        }

        .status-bar {
            margin-top: 15px;
            padding: 12px 15px;
            background: rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-bar strong {
            color: #38ef7d;
        }

        .room-status {
            background: #38ef7d;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .connected-ids-list {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .connected-id-tag {
            background: rgba(56, 239, 125, 0.2);
            border: 1px solid #38ef7d;
            color: #38ef7d;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .connected-id-tag.connecting {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffc107;
        }

        .connected-id-tag.reconnecting {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            color: #ffa500;
        }

        .connected-id-tag.failed {
            background: rgba(235, 51, 73, 0.2);
            border-color: #eb3349;
            color: #eb3349;
        }

        .retry-badge {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .chat-box {
            height: 250px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #3a3a5a;
        }

        .chat-box .placeholder-text {
            color: #555;
            text-align: center;
            font-style: italic;
        }

        .chat-message {
            padding: 10px 14px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .chat-message.own {
            background: rgba(56, 239, 125, 0.1);
            border-left-color: #38ef7d;
        }

        .chat-message .from {
            font-weight: 600;
            color: #667eea;
            font-size: 0.85rem;
        }

        .chat-message.own .from {
            color: #38ef7d;
        }

        .chat-message .text {
            margin-top: 5px;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .chat-message .time {
            font-size: 0.7rem;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .log-box {
            height: 150px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            border: 1px solid #3a3a5a;
        }

        .log-box p {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .log-box .success {
            background: rgba(56, 239, 125, 0.1);
            color: #38ef7d;
        }

        .log-box .error {
            background: rgba(235, 51, 73, 0.1);
            color: #eb3349;
        }

        .log-box .info {
            background: rgba(102, 126, 234, 0.1);
            color: #a0a0ff;
        }

        .log-box .warning {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sending-active {
            animation: pulse 1s infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .reconnecting-icon {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .connection-indicator.connected {
            background: #38ef7d;
        }

        .connection-indicator.disconnected {
            background: #eb3349;
        }

        .connection-indicator.connecting {
            background: #ffc107;
            animation: pulse 0.5s infinite;
        }

        .worker-status {
            font-size: 0.75rem;
            color: #888;
            margin-left: 10px;
        }

        .worker-status.active {
            color: #38ef7d;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .button-group {
                flex-direction: column;
            }
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Simple Chat Client</h1>

        <!-- Section 1: Connection -->
        <div class="section">
            <h2>1. Connect IDs <span class="worker-status" id="workerStatus">‚óè Worker Active</span></h2>
            <div class="form-group">
                <label>Enter IDs (separated by #, max 20):</label>
                <textarea id="inputIds" placeholder="id1#id2#id3#id4..." rows="3"></textarea>
            </div>
            <div class="form-group">
                <label>Password (same for all IDs):</label>
                <input type="password" id="inputPassword" placeholder="Enter password">
            </div>
            
            <div class="form-group">
                <label>Connection Mode:</label>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="all" checked>
                        <span>Connect All at Once</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="sequential">
                        <span>Connect One by One</span>
                    </label>
                </div>
            </div>
            
            <div class="form-group hidden" id="delayGroup">
                <label>Delay between connections (ms):</label>
                <input type="number" id="connectionDelay" value="1000" min="100" step="100">
            </div>

            <div class="button-group">
                <button id="btnConnect" class="btn btn-primary">Connect</button>
                <button id="btnDisconnect" class="btn btn-danger" disabled>Disconnect All</button>
            </div>
            
            <div class="status-bar">
                <span>
                    <span class="connection-indicator disconnected" id="mainIndicator"></span>
                    Connected: <strong id="connectedCount">0</strong> IDs
                </span>
                <span id="reconnectStatus"></span>
            </div>
            <div id="connectedIdsList" class="connected-ids-list"></div>
        </div>

        <!-- Section 2: Room -->
        <div class="section">
            <h2>2. Room Management</h2>
            
            <div class="form-group">
                <label>Room Name:</label>
                <input type="text" id="inputRoom" placeholder="Enter room name or select from list below">
            </div>
            
            <div class="form-group">
                <div class="room-list-header">
                    <label>Available Rooms:</label>
                    <button id="btnFetchRooms" class="btn btn-small btn-secondary" disabled>Fetch Rooms</button>
                </div>
                <select id="roomList" size="5">
                    <option value="" disabled>-- Click "Fetch Rooms" to load --</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="btnJoinRoom" class="btn btn-primary" disabled>Join Room</button>
                <button id="btnLeaveRoom" class="btn btn-warning" disabled>Leave Room</button>
            </div>
            
            <div id="currentRoomStatus" class="status-bar hidden">
                <span>Current Room: <strong id="currentRoom"></strong></span>
                <span class="room-status" id="roomStatus">In Room</span>
            </div>
        </div>

        <!-- Section 3: Messages -->
        <div class="section">
            <h2>3. Messages</h2>
            
            <div class="form-group">
                <label>Messages to Send (one per line - will loop continuously):</label>
                <textarea id="inputMessages" placeholder="Enter messages here, one per line...&#10;Message 1&#10;Message 2&#10;Message 3&#10;&#10;These will be sent in a loop until you stop." rows="8"></textarea>
            </div>
            
            <div class="form-group">
                <label>Send Interval (ms):</label>
                <input type="number" id="messageInterval" value="3000" min="500" step="500">
                <span class="hint">Minimum 500ms between messages</span>
            </div>
            
            <div class="button-group">
                <button id="btnStartLoop" class="btn btn-success">Start Sending</button>
                <button id="btnStopLoop" class="btn btn-danger" disabled>Stop Sending</button>
            </div>
            
            <div id="messageStatus" class="status-bar hidden">
                <span>Status: <strong id="loopStatus">Sending...</strong></span>
                <span>Messages Sent: <strong id="messagesSentCount">0</strong></span>
            </div>
        </div>

        <!-- Section 4: Chat Display -->
        <div class="section">
            <h2>4. Room Chat</h2>
            <div class="chat-box" id="chatBox">
                <p class="placeholder-text">Join a room to see messages...</p>
            </div>
        </div>

        <!-- Section 5: Log -->
        <div class="section">
            <h2>üìã Activity Log</h2>
            <div class="log-box" id="logBox">
                <p class="info">Application started...</p>
            </div>
            <button id="btnClearLog" class="btn btn-secondary btn-small">Clear Log</button>
        </div>
    </div>

    <script>
        // ==================== WEB WORKER CODE (INLINE) ====================
        // This runs in a separate thread and is NOT throttled when tab is minimized
        
        const workerCode = `
            // Client connections stored in worker
            const clients = new Map();
            const clientStates = new Map();
            
            // Message loop state
            let messageLoopInterval = null;
            let messageLoopData = null;
            
            class WorkerClient {
                constructor(username, password, autoReconnect = true) {
                    this.URL = 'wss://chatp.net:5333/server';
                    this.webSocket = null;
                    this.userName = username;
                    this.passWord = password;
                    this.currentRoom = "";
                    this.isConnected = false;
                    this.isInRoom = false;
                    this.pingInterval = null;
                    this.reconnectTimeout = null;
                    this.retryCount = 0;
                    this.autoReconnect = autoReconnect;
                    this.isManualDisconnect = false;
                    this.lastRoom = "";
                    this.baseReconnectDelay = 2000;
                    this.maxReconnectDelay = 30000;
                    
                    this.connect();
                }
                
                connect() {
                    try {
                        if (this.webSocket) {
                            try { this.webSocket.close(); } catch(e) {}
                        }
                        
                        this.webSocket = new WebSocket(this.URL);
                        
                        this.webSocket.onopen = () => this._onOpen();
                        this.webSocket.onclose = (e) => this._onClose(e);
                        this.webSocket.onmessage = (e) => this._onMsg(e);
                        this.webSocket.onerror = (e) => this._onError(e);
                        
                    } catch (error) {
                        this._postMessage('log', { username: this.userName, message: 'Connection error: ' + error.message });
                        this._scheduleReconnect();
                    }
                }
                
                disconnect() {
                    this.isManualDisconnect = true;
                    this.autoReconnect = false;
                    this.isConnected = false;
                    this.isInRoom = false;
                    this._clearTimers();
                    
                    if (this.webSocket) {
                        try { this.webSocket.close(); } catch(e) {}
                        this.webSocket = null;
                    }
                }
                
                _clearTimers() {
                    if (this.pingInterval) {
                        clearInterval(this.pingInterval);
                        this.pingInterval = null;
                    }
                    if (this.reconnectTimeout) {
                        clearTimeout(this.reconnectTimeout);
                        this.reconnectTimeout = null;
                    }
                }
                
                _scheduleReconnect() {
                    if (!this.autoReconnect || this.isManualDisconnect) return;
                    
                    const delay = Math.min(
                        this.baseReconnectDelay * Math.pow(1.5, this.retryCount) + Math.random() * 1000,
                        this.maxReconnectDelay
                    );
                    
                    this.retryCount++;
                    this._postMessage('reconnecting', { 
                        username: this.userName, 
                        attempt: this.retryCount, 
                        delay: delay 
                    });
                    
                    this.reconnectTimeout = setTimeout(() => {
                        this.connect();
                    }, delay);
                }
                
                _onOpen() {
                    this._postMessage('log', { username: this.userName, message: 'Socket opened, logging in...' });
                    this.login();
                }
                
                _onClose(event) {
                    this._postMessage('log', { username: this.userName, message: 'Socket closed (code: ' + event.code + ')' });
                    this.isConnected = false;
                    this.isInRoom = false;
                    this._clearTimers();
                    
                    if (!this.isManualDisconnect) {
                        this._postMessage('disconnected', { username: this.userName, willReconnect: true });
                        this._scheduleReconnect();
                    } else {
                        this._postMessage('disconnected', { username: this.userName, willReconnect: false });
                    }
                }
                
                _onError(error) {
                    this._postMessage('log', { username: this.userName, message: 'WebSocket error' });
                }
                
                _onMsg(event) {
                    try {
                        const payload = event.data;
                        if (!payload || payload.length === 0) return;
                        
                        const parsedData = JSON.parse(payload);
                        this._handleParsedData(parsedData);
                    } catch (error) {}
                }
                
                _handleParsedData(parsedData) {
                    if (parsedData.handler === "login_event") {
                        if (parsedData.type === "success") {
                            this.isConnected = true;
                            this.retryCount = 0;
                            this._startPingInterval();
                            this._postMessage('log', { username: this.userName, message: 'Login successful' });
                            
                            if (this.lastRoom) {
                                this._postMessage('log', { username: this.userName, message: 'Rejoining room: ' + this.lastRoom });
                                this.joinRoom(this.lastRoom);
                                this._postMessage('reconnected', { username: this.userName, room: this.lastRoom });
                            } else {
                                this._postMessage('loginSuccess', { username: this.userName });
                            }
                        } else {
                            this._postMessage('log', { username: this.userName, message: 'Login failed: ' + (parsedData.reason || parsedData.type) });
                            if (parsedData.reason === 'invalid_password' || parsedData.reason === 'invalid_username') {
                                this.autoReconnect = false;
                                this._postMessage('loginFailed', { username: this.userName, reason: parsedData.reason || parsedData.type });
                            } else {
                                this._scheduleReconnect();
                            }
                        }
                    }
                    
                    if (parsedData.handler === "room_list") {
                        if (parsedData.rooms) {
                            this._postMessage('roomList', { rooms: parsedData.rooms });
                        }
                    }
                    
                    if (parsedData.handler === "room_event") {
                        if (parsedData.type === "text") {
                            this._postMessage('message', { 
                                from: parsedData.from, 
                                body: parsedData.body, 
                                room: parsedData.room 
                            });
                        }
                        
                        if (parsedData.type === "join_success" || parsedData.type === "joined") {
                            const room = parsedData.name || parsedData.room;
                            this.currentRoom = room;
                            this.lastRoom = room;
                            this.isInRoom = true;
                            this._postMessage('roomJoined', { username: this.userName, room: room });
                        }
                        
                        if (parsedData.type === "leave_success" || parsedData.type === "left") {
                            const room = parsedData.name || parsedData.room || this.currentRoom;
                            this.currentRoom = "";
                            this.lastRoom = "";
                            this.isInRoom = false;
                            this._postMessage('roomLeft', { username: this.userName, room: room });
                        }
                    }
                }
                
                _startPingInterval() {
                    if (this.pingInterval) clearInterval(this.pingInterval);
                    
                    // Ping every 15 seconds - Worker timers are NOT throttled
                    this.pingInterval = setInterval(() => {
                        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                            this.webSocket.send("");
                        } else if (!this.isManualDisconnect && this.autoReconnect) {
                            this._clearTimers();
                            this._scheduleReconnect();
                        }
                    }, 15000);
                }
                
                _postMessage(type, data) {
                    self.postMessage({ type, ...data });
                }
                
                login() {
                    const payload = {
                        handler: "login",
                        id: this.keyGen(20),
                        username: this.userName,
                        password: this.passWord
                    };
                    
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send(JSON.stringify(payload));
                    }
                }
                
                requestRoomList() {
                    const payload = { handler: "room_list", id: this.keyGen(20) };
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send(JSON.stringify(payload));
                        return true;
                    }
                    return false;
                }
                
                joinRoom(roomName) {
                    const payload = { handler: "room_join", id: this.keyGen(20), name: roomName };
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send(JSON.stringify(payload));
                        this.currentRoom = roomName;
                        this.lastRoom = roomName;
                        return true;
                    }
                    return false;
                }
                
                leaveRoom(roomName) {
                    const payload = { handler: "room_leave", id: this.keyGen(20), name: roomName || this.currentRoom };
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send(JSON.stringify(payload));
                        this.isInRoom = false;
                        this.currentRoom = "";
                        this.lastRoom = "";
                        return true;
                    }
                    return false;
                }
                
                sendMessage(roomName, message) {
                    const payload = {
                        handler: "room_message",
                        id: this.keyGen(20, true),
                        room: roomName,
                        type: "text",
                        url: "",
                        body: message,
                        length: ""
                    };
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send(JSON.stringify(payload));
                        return true;
                    }
                    return false;
                }
                
                isAlive() {
                    return this.webSocket && this.webSocket.readyState === WebSocket.OPEN && this.isConnected;
                }
                
                keyGen(length, isMsgId = false) {
                    let key = "";
                    let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                    if (isMsgId) chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ";
                    for (let i = 0; i < length; i++) {
                        key += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return key;
                }
            }
            
            // Handle messages from main thread
            self.onmessage = function(e) {
                const { action, data } = e.data;
                
                switch(action) {
                    case 'connect':
                        const client = new WorkerClient(data.username, data.password, data.autoReconnect);
                        clients.set(data.username, client);
                        clientStates.set(data.username, 'connecting');
                        break;
                        
                    case 'disconnect':
                        if (clients.has(data.username)) {
                            clients.get(data.username).disconnect();
                            clients.delete(data.username);
                            clientStates.delete(data.username);
                        }
                        break;
                        
                    case 'disconnectAll':
                        stopMessageLoop();
                        clients.forEach((client, username) => {
                            client.disconnect();
                        });
                        clients.clear();
                        clientStates.clear();
                        self.postMessage({ type: 'allDisconnected' });
                        break;
                        
                    case 'fetchRooms':
                        clients.forEach((client) => {
                            if (client.isAlive()) {
                                client.requestRoomList();
                                return;
                            }
                        });
                        break;
                        
                    case 'joinRoom':
                        clients.forEach((client) => {
                            if (client.isAlive()) {
                                client.joinRoom(data.roomName);
                            }
                        });
                        break;
                        
                    case 'leaveRoom':
                        stopMessageLoop();
                        clients.forEach((client) => {
                            if (client.isAlive()) {
                                client.leaveRoom(data.roomName);
                            }
                        });
                        break;
                        
                    case 'startMessageLoop':
                        startMessageLoop(data.roomName, data.messages, data.interval);
                        break;
                        
                    case 'stopMessageLoop':
                        stopMessageLoop();
                        break;
                        
                    case 'getStatus':
                        const status = {};
                        clients.forEach((client, username) => {
                            status[username] = {
                                isConnected: client.isConnected,
                                isInRoom: client.isInRoom,
                                currentRoom: client.currentRoom,
                                isAlive: client.isAlive()
                            };
                        });
                        self.postMessage({ type: 'status', status });
                        break;
                }
            };
            
            function startMessageLoop(roomName, messages, interval) {
                stopMessageLoop();
                
                if (!messages || messages.length === 0) {
                    self.postMessage({ type: 'log', message: 'No messages to send' });
                    return;
                }
                
                messageLoopData = { roomName, messages, interval, index: 0, count: 0 };
                
                const sendNext = () => {
                    if (!messageLoopData) return;
                    
                    const message = messageLoopData.messages[messageLoopData.index % messageLoopData.messages.length];
                    let sentCount = 0;
                    
                    clients.forEach((client) => {
                        if (client.isAlive() && (client.isInRoom || client.currentRoom === messageLoopData.roomName)) {
                            client.sendMessage(messageLoopData.roomName, message);
                            sentCount++;
                        }
                    });
                    
                    if (sentCount > 0) {
                        messageLoopData.count++;
                        self.postMessage({ type: 'messageSent', count: messageLoopData.count });
                    }
                    
                    messageLoopData.index++;
                };
                
                sendNext();
                messageLoopInterval = setInterval(sendNext, interval);
                self.postMessage({ type: 'messageLoopStarted' });
            }
            
            function stopMessageLoop() {
                if (messageLoopInterval) {
                    clearInterval(messageLoopInterval);
                    messageLoopInterval = null;
                }
                messageLoopData = null;
                self.postMessage({ type: 'messageLoopStopped' });
            }
            
            // Heartbeat to confirm worker is alive
            setInterval(() => {
                self.postMessage({ type: 'heartbeat', clientCount: clients.size });
            }, 5000);
        `;
        
        // ==================== MAIN APPLICATION ====================
        
        // Create worker from inline code
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        const worker = new Worker(workerUrl);
        
        // State
        let connectedIdsSet = new Set();
        let clientStates = new Map();
        let activeRoom = '';
        let isInRoom = false;
        let isMessageLoopRunning = false;
        let messagesSent = 0;
        let pendingConnections = new Map();
        
        // Elements
        const inputIds = document.getElementById('inputIds');
        const inputPassword = document.getElementById('inputPassword');
        const btnConnect = document.getElementById('btnConnect');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const connectedCount = document.getElementById('connectedCount');
        const connectedIdsList = document.getElementById('connectedIdsList');
        const delayGroup = document.getElementById('delayGroup');
        const connectionDelay = document.getElementById('connectionDelay');
        const mainIndicator = document.getElementById('mainIndicator');
        const reconnectStatusEl = document.getElementById('reconnectStatus');
        const workerStatusEl = document.getElementById('workerStatus');

        const inputRoom = document.getElementById('inputRoom');
        const roomList = document.getElementById('roomList');
        const btnFetchRooms = document.getElementById('btnFetchRooms');
        const btnJoinRoom = document.getElementById('btnJoinRoom');
        const btnLeaveRoom = document.getElementById('btnLeaveRoom');
        const currentRoomStatus = document.getElementById('currentRoomStatus');
        const currentRoomEl = document.getElementById('currentRoom');
        const roomStatus = document.getElementById('roomStatus');

        const inputMessages = document.getElementById('inputMessages');
        const messageInterval = document.getElementById('messageInterval');
        const btnStartLoop = document.getElementById('btnStartLoop');
        const btnStopLoop = document.getElementById('btnStopLoop');
        const messageStatus = document.getElementById('messageStatus');
        const loopStatusEl = document.getElementById('loopStatus');
        const messagesSentCount = document.getElementById('messagesSentCount');

        const chatBox = document.getElementById('chatBox');
        const logBox = document.getElementById('logBox');
        const btnClearLog = document.getElementById('btnClearLog');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            setupWorkerHandlers();
        });

        function setupEventListeners() {
            document.querySelectorAll('input[name="connectMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    delayGroup.classList.toggle('hidden', e.target.value !== 'sequential');
                });
            });
            
            btnConnect.addEventListener('click', connectIds);
            btnDisconnect.addEventListener('click', disconnectAll);
            btnFetchRooms.addEventListener('click', fetchRooms);
            
            roomList.addEventListener('change', () => {
                inputRoom.value = roomList.value;
            });
            
            roomList.addEventListener('dblclick', () => {
                if (roomList.value) {
                    inputRoom.value = roomList.value;
                    joinRoom();
                }
            });
            
            btnJoinRoom.addEventListener('click', joinRoom);
            btnLeaveRoom.addEventListener('click', leaveRoom);
            btnStartLoop.addEventListener('click', startMessageLoop);
            btnStopLoop.addEventListener('click', stopMessageLoop);
            
            btnClearLog.addEventListener('click', () => {
                logBox.innerHTML = '<p class="info">Log cleared</p>';
            });
        }

        function setupWorkerHandlers() {
            worker.onmessage = function(e) {
                const data = e.data;
                
                switch(data.type) {
                    case 'log':
                        addLog(`[${data.username || 'System'}] ${data.message}`);
                        break;
                        
                    case 'loginSuccess':
                        connectedIdsSet.add(data.username);
                        clientStates.set(data.username, 'connected');
                        updateIdTagState(data.username, 'connected');
                        updateConnectionUI();
                        
                        if (pendingConnections.has(data.username)) {
                            pendingConnections.get(data.username).resolve({ success: true });
                            pendingConnections.delete(data.username);
                        }
                        break;
                        
                    case 'loginFailed':
                        clientStates.set(data.username, 'failed');
                        updateIdTagState(data.username, 'failed');
                        
                        if (pendingConnections.has(data.username)) {
                            pendingConnections.get(data.username).resolve({ success: false, message: data.reason });
                            pendingConnections.delete(data.username);
                        }
                        break;
                        
                    case 'disconnected':
                        if (data.willReconnect) {
                            clientStates.set(data.username, 'reconnecting');
                            updateIdTagState(data.username, 'reconnecting');
                        } else {
                            connectedIdsSet.delete(data.username);
                            clientStates.delete(data.username);
                            updateConnectionUI();
                        }
                        break;
                        
                    case 'reconnecting':
                        clientStates.set(data.username, 'reconnecting');
                        updateIdTagState(data.username, 'reconnecting', data.attempt);
                        updateReconnectStatus();
                        break;
                        
                    case 'reconnected':
                        clientStates.set(data.username, 'connected');
                        connectedIdsSet.add(data.username);
                        updateIdTagState(data.username, 'connected');
                        updateConnectionUI();
                        updateReconnectStatus();
                        addLog(`[${data.username}] Reconnected successfully!`, 'success');
                        break;
                        
                    case 'message':
                        addChatMessage(data.from, data.body, data.room);
                        break;
                        
                    case 'roomList':
                        updateRoomListUI(data.rooms);
                        break;
                        
                    case 'roomJoined':
                        isInRoom = true;
                        activeRoom = data.room;
                        updateRoomStatusUI();
                        addLog(`[${data.username}] Joined room: ${data.room}`, 'success');
                        break;
                        
                    case 'roomLeft':
                        addLog(`[${data.username}] Left room: ${data.room}`, 'info');
                        break;
                        
                    case 'allDisconnected':
                        connectedIdsSet.clear();
                        clientStates.clear();
                        activeRoom = '';
                        isInRoom = false;
                        messagesSent = 0;
                        isMessageLoopRunning = false;
                        updateConnectionUI();
                        updateMessageLoopUI();
                        connectedIdsList.innerHTML = '';
                        reconnectStatusEl.textContent = '';
                        roomList.innerHTML = '<option value="" disabled>-- Click "Fetch Rooms" to load --</option>';
                        currentRoomStatus.classList.add('hidden');
                        messageStatus.classList.add('hidden');
                        addLog('All IDs disconnected', 'info');
                        break;
                        
                    case 'messageSent':
                        messagesSent = data.count;
                        messagesSentCount.textContent = messagesSent;
                        break;
                        
                    case 'messageLoopStarted':
                        isMessageLoopRunning = true;
                        updateMessageLoopUI();
                        break;
                        
                    case 'messageLoopStopped':
                        isMessageLoopRunning = false;
                        updateMessageLoopUI();
                        break;
                        
                    case 'heartbeat':
                        workerStatusEl.textContent = '‚óè Worker Active (' + data.clientCount + ' clients)';
                        workerStatusEl.classList.add('active');
                        break;
                }
            };
            
            worker.onerror = function(e) {
                addLog('Worker error: ' + e.message, 'error');
                workerStatusEl.textContent = '‚óè Worker Error';
                workerStatusEl.classList.remove('active');
            };
        }

        function updateIdTagState(username, state, retryCount = 0) {
            const tag = document.getElementById(`tag-${username}`);
            if (tag) {
                tag.className = 'connected-id-tag';
                let content = username;
                
                if (state === 'connecting') {
                    tag.classList.add('connecting');
                    content = `‚è≥ ${username}`;
                } else if (state === 'reconnecting') {
                    tag.classList.add('reconnecting');
                    content = `<span class="reconnecting-icon">üîÑ</span> ${username}`;
                    if (retryCount > 0) {
                        content += ` <span class="retry-badge">retry ${retryCount}</span>`;
                    }
                } else if (state === 'failed') {
                    tag.classList.add('failed');
                    content = `‚ùå ${username}`;
                } else if (state === 'connected') {
                    content = `‚úì ${username}`;
                }
                
                tag.innerHTML = content;
            }
        }

        function updateReconnectStatus() {
            const reconnecting = [];
            clientStates.forEach((state, username) => {
                if (state === 'reconnecting') {
                    reconnecting.push(username);
                }
            });
            
            if (reconnecting.length > 0) {
                reconnectStatusEl.innerHTML = `<span class="reconnecting-icon">üîÑ</span> Reconnecting ${reconnecting.length} ID(s)...`;
            } else {
                reconnectStatusEl.textContent = '';
            }
        }

        async function connectIds() {
            const idsText = inputIds.value.trim();
            const password = inputPassword.value.trim();
            
            if (!idsText) {
                addLog('Please enter at least one ID', 'error');
                return;
            }
            
            if (!password) {
                addLog('Please enter password', 'error');
                return;
            }
            
            const ids = idsText.split('#').map(id => id.trim()).filter(id => id);
            
            if (ids.length === 0) {
                addLog('No valid IDs found', 'error');
                return;
            }
            
            if (ids.length > 20) {
                addLog('Maximum 20 IDs allowed', 'error');
                return;
            }
            
            const mode = document.querySelector('input[name="connectMode"]:checked').value;
            const delay = parseInt(connectionDelay.value) || 1000;
            
            btnConnect.disabled = true;
            btnConnect.textContent = 'Connecting...';
            
            connectedIdsList.innerHTML = '';
            ids.forEach(id => {
                const tag = document.createElement('span');
                tag.className = 'connected-id-tag connecting';
                tag.id = `tag-${id}`;
                tag.innerHTML = `‚è≥ ${id}`;
                connectedIdsList.appendChild(tag);
                clientStates.set(id, 'connecting');
            });
            
            addLog(`Connecting ${ids.length} IDs (${mode === 'all' ? 'all at once' : 'one by one'})...`, 'info');
            
            try {
                if (mode === 'all') {
                    const promises = ids.map(id => connectSingleId(id, password));
                    await Promise.all(promises);
                } else {
                    for (const id of ids) {
                        await connectSingleId(id, password);
                        if (delay > 0) {
                            await new Promise(r => setTimeout(r, delay));
                        }
                    }
                }
                
                const successCount = Array.from(clientStates.values()).filter(s => s === 'connected').length;
                const failCount = Array.from(clientStates.values()).filter(s => s === 'failed').length;
                addLog(`Finished: Connected ${successCount}, Failed ${failCount}`, successCount > 0 ? 'success' : 'error');
                
                if (connectedIdsSet.size > 0) {
                    btnDisconnect.disabled = false;
                    btnFetchRooms.disabled = false;
                    btnJoinRoom.disabled = false;
                }
                
            } catch (error) {
                addLog(`Connection error: ${error.message}`, 'error');
            }
            
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect';
        }

        function connectSingleId(username, password) {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    if (pendingConnections.has(username)) {
                        pendingConnections.delete(username);
                        clientStates.set(username, 'failed');
                        updateIdTagState(username, 'failed');
                        resolve({ success: false, message: 'Timeout' });
                    }
                }, 20000);
                
                pendingConnections.set(username, { 
                    resolve: (result) => {
                        clearTimeout(timeout);
                        resolve(result);
                    }
                });
                
                worker.postMessage({
                    action: 'connect',
                    data: { username, password, autoReconnect: true }
                });
            });
        }

        function updateConnectionUI() {
            const connected = connectedIdsSet.size;
            connectedCount.textContent = connected;
            
            mainIndicator.className = 'connection-indicator';
            if (connected > 0) {
                mainIndicator.classList.add('connected');
                btnDisconnect.disabled = false;
                btnFetchRooms.disabled = false;
                btnJoinRoom.disabled = false;
            } else {
                mainIndicator.classList.add('disconnected');
                btnDisconnect.disabled = true;
                btnFetchRooms.disabled = true;
                btnJoinRoom.disabled = true;
                btnLeaveRoom.disabled = true;
            }
        }

        function disconnectAll() {
            worker.postMessage({ action: 'disconnectAll', data: {} });
            btnDisconnect.disabled = true;
            btnFetchRooms.disabled = true;
            btnJoinRoom.disabled = true;
            btnLeaveRoom.disabled = true;
        }

        function fetchRooms() {
            if (connectedIdsSet.size === 0) {
                addLog('Connect IDs first to fetch rooms', 'error');
                return;
            }
            
            btnFetchRooms.disabled = true;
            btnFetchRooms.textContent = 'Fetching...';
            
            worker.postMessage({ action: 'fetchRooms', data: {} });
            addLog('Fetching room list...', 'info');
            
            setTimeout(() => {
                btnFetchRooms.disabled = false;
                btnFetchRooms.textContent = 'Fetch Rooms';
            }, 2000);
        }

        function updateRoomListUI(rooms) {
            roomList.innerHTML = '';
            
            if (rooms && rooms.length > 0) {
                rooms.forEach(room => {
                    const option = document.createElement('option');
                    const roomName = typeof room === 'string' ? room : (room.name || room.room || room);
                    option.value = roomName;
                    option.textContent = roomName;
                    roomList.appendChild(option);
                });
                addLog(`Loaded ${rooms.length} rooms`, 'success');
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.disabled = true;
                option.textContent = '-- No rooms found --';
                roomList.appendChild(option);
            }
        }

        function joinRoom() {
            const roomName = inputRoom.value.trim();
            
            if (!roomName) {
                addLog('Please enter or select a room name', 'error');
                return;
            }
            
            if (connectedIdsSet.size === 0) {
                addLog('No IDs connected', 'error');
                return;
            }
            
            btnJoinRoom.disabled = true;
            btnJoinRoom.textContent = 'Joining...';
            
            worker.postMessage({ action: 'joinRoom', data: { roomName } });
            
            activeRoom = roomName;
            isInRoom = true;
            
            currentRoomEl.textContent = roomName;
            currentRoomStatus.classList.remove('hidden');
            roomStatus.textContent = 'In Room';
            roomStatus.style.background = '#38ef7d';
            
            btnLeaveRoom.disabled = false;
            chatBox.innerHTML = '';
            
            addLog(`All IDs joining room: ${roomName}`, 'info');
            
            setTimeout(() => {
                btnJoinRoom.disabled = false;
                btnJoinRoom.textContent = 'Join Room';
            }, 1000);
        }

        function leaveRoom() {
            if (!activeRoom) {
                addLog('Not in any room', 'error');
                return;
            }
            
            btnLeaveRoom.disabled = true;
            btnLeaveRoom.textContent = 'Leaving...';
            
            worker.postMessage({ action: 'leaveRoom', data: { roomName: activeRoom } });
            
            isInRoom = false;
            roomStatus.textContent = 'Left';
            roomStatus.style.background = '#eb3349';
            
            addLog(`All IDs leaving room: ${activeRoom}`, 'info');
            activeRoom = '';
            
            setTimeout(() => {
                currentRoomStatus.classList.add('hidden');
                btnLeaveRoom.disabled = true;
                btnLeaveRoom.textContent = 'Leave Room';
            }, 2000);
        }

        function updateRoomStatusUI() {
            if (isInRoom && activeRoom) {
                currentRoomEl.textContent = activeRoom;
                currentRoomStatus.classList.remove('hidden');
                roomStatus.textContent = 'In Room';
                roomStatus.style.background = '#38ef7d';
                btnLeaveRoom.disabled = false;
            }
        }

        function startMessageLoop() {
            const messagesText = inputMessages.value.trim();
            
            if (!messagesText) {
                addLog('Please enter messages to send', 'error');
                return;
            }
            
            if (!activeRoom) {
                addLog('Please join a room first', 'error');
                return;
            }
            
            if (!isInRoom) {
                addLog('Not in a room. Please join a room first.', 'error');
                return;
            }
            
            const messages = messagesText.split('\n').map(m => m.trim()).filter(m => m);
            
            if (messages.length === 0) {
                addLog('No valid messages found', 'error');
                return;
            }
            
            const interval = Math.max(500, parseInt(messageInterval.value) || 3000);
            
            messagesSent = 0;
            messagesSentCount.textContent = '0';
            
            worker.postMessage({
                action: 'startMessageLoop',
                data: { roomName: activeRoom, messages, interval }
            });
            
            addLog(`Starting message loop: ${messages.length} messages, ${interval}ms interval`, 'success');
        }

        function stopMessageLoop() {
            worker.postMessage({ action: 'stopMessageLoop', data: {} });
            addLog('Stopping message loop...', 'info');
        }

        function updateMessageLoopUI() {
            if (isMessageLoopRunning) {
                btnStartLoop.disabled = true;
                btnStopLoop.disabled = false;
                messageStatus.classList.remove('hidden');
                loopStatusEl.textContent = 'Sending...';
                loopStatusEl.classList.add('sending-active');
            } else {
                btnStartLoop.disabled = false;
                btnStopLoop.disabled = true;
                loopStatusEl.textContent = 'Stopped';
                loopStatusEl.classList.remove('sending-active');
            }
        }

        function addChatMessage(from, message, room) {
            const placeholder = chatBox.querySelector('.placeholder-text');
            if (placeholder) placeholder.remove();
            
            const time = new Date().toLocaleTimeString();
            const isOwn = connectedIdsSet.has(from);
            
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
            
            msgDiv.innerHTML = `
                <div class="from">${escapeHtml(from)}</div>
                <div class="text">${escapeHtml(message)}</div>
                <div class="time">${time}</div>
            `;
            
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            while (chatBox.children.length > 100) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }

        function addLog(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const p = document.createElement('p');
            p.className = type;
            p.textContent = `[${time}] ${message}`;
            logBox.appendChild(p);
            logBox.scrollTop = logBox.scrollHeight;
            
            while (logBox.children.length > 200) {
                logBox.removeChild(logBox.firstChild);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>