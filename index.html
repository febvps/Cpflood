<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #667eea;
        }

        h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #a0a0ff;
            border-bottom: 1px solid #3a3a5a;
            padding-bottom: 8px;
        }

        .section {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a5a;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.95rem;
        }

        input[type="number"] {
            width: 150px;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            line-height: 1.5;
        }

        textarea#inputMessages {
            min-height: 150px;
            font-size: 0.95rem;
        }

        select {
            cursor: pointer;
        }

        select option {
            padding: 8px;
            background: #1a1a2e;
        }

        .hint {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #ccc;
        }

        .radio-label input[type="radio"],
        .radio-label input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .room-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .room-list-header label {
            margin-bottom: 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #ccc;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4a4a6a;
        }

        .btn-orange {
            background: linear-gradient(135deg, #f5af19 0%, #f12711 100%);
            color: white;
        }

        .status-bar {
            margin-top: 15px;
            padding: 12px 15px;
            background: rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-bar strong {
            color: #38ef7d;
        }

        .room-status {
            background: #38ef7d;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .keep-alive-status {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            background: rgba(56, 239, 125, 0.2);
            color: #38ef7d;
        }

        .connected-ids-list {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .connected-id-tag {
            background: rgba(56, 239, 125, 0.2);
            border: 1px solid #38ef7d;
            color: #38ef7d;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .connected-id-tag.connecting {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffc107;
        }

        .connected-id-tag.reconnecting {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            color: #ffa500;
        }

        .connected-id-tag.failed {
            background: rgba(235, 51, 73, 0.2);
            border-color: #eb3349;
            color: #eb3349;
        }

        .connected-id-tag.banned {
            background: rgba(139, 0, 0, 0.3);
            border-color: #8b0000;
            color: #ff6b6b;
        }

        .connected-id-tag.in-room {
            background: rgba(56, 239, 125, 0.3);
            border-color: #38ef7d;
        }

        .retry-badge {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .device-id-display {
            font-size: 0.7rem;
            color: #888;
            margin-left: 5px;
        }

        .chat-box {
            height: 250px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #3a3a5a;
        }

        .chat-box .placeholder-text {
            color: #555;
            text-align: center;
            font-style: italic;
        }

        .chat-message {
            padding: 10px 14px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .chat-message.own {
            background: rgba(56, 239, 125, 0.1);
            border-left-color: #38ef7d;
        }

        .chat-message .from {
            font-weight: 600;
            color: #667eea;
            font-size: 0.85rem;
        }

        .chat-message.own .from {
            color: #38ef7d;
        }

        .chat-message .text {
            margin-top: 5px;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .chat-message .time {
            font-size: 0.7rem;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .log-box {
            height: 200px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            border: 1px solid #3a3a5a;
        }

        .log-box p {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .log-box .success {
            background: rgba(56, 239, 125, 0.1);
            color: #38ef7d;
        }

        .log-box .error {
            background: rgba(235, 51, 73, 0.1);
            color: #eb3349;
        }

        .log-box .info {
            background: rgba(102, 126, 234, 0.1);
            color: #a0a0ff;
        }

        .log-box .warning {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
        }

        .log-box .ban {
            background: rgba(139, 0, 0, 0.2);
            color: #ff6b6b;
            font-weight: bold;
        }

        .log-box .event {
            background: rgba(138, 43, 226, 0.1);
            color: #da70d6;
        }

        .log-box .raw {
            background: rgba(100, 100, 100, 0.1);
            color: #aaa;
            font-size: 0.7rem;
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sending-active {
            animation: pulse 1s infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .reconnecting-icon {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .connection-indicator.connected {
            background: #38ef7d;
        }

        .connection-indicator.disconnected {
            background: #eb3349;
        }

        .connection-indicator.connecting {
            background: #ffc107;
            animation: pulse 0.5s infinite;
        }

        .important-notice {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .important-notice h3 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .important-notice ul {
            margin-left: 20px;
            color: #ccc;
        }

        .important-notice li {
            margin-bottom: 5px;
        }

        .ip-section {
            background: rgba(235, 51, 73, 0.1);
            border: 1px solid #eb3349;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .ip-section h4 {
            color: #eb3349;
            margin-bottom: 10px;
        }

        .current-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .current-info-item {
            display: flex;
            flex-direction: column;
        }

        .current-info-item label {
            font-size: 0.75rem;
            color: #888;
        }

        .current-info-item span {
            font-family: monospace;
            color: #38ef7d;
        }

        .join-progress {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .join-progress-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #3a3a5a;
        }

        .join-progress-item:last-child {
            border-bottom: none;
        }

        .join-progress-item .status-icon {
            width: 20px;
            text-align: center;
        }

        .join-progress-item .username {
            flex: 1;
            font-weight: 500;
        }

        .join-progress-item .device-id {
            font-size: 0.75rem;
            color: #888;
            font-family: monospace;
        }

        .join-progress-item .status-text {
            font-size: 0.85rem;
            padding: 2px 8px;
            border-radius: 4px;
        }

        .join-progress-item .status-text.waiting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .join-progress-item .status-text.joining {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        .join-progress-item .status-text.joined {
            background: rgba(56, 239, 125, 0.2);
            color: #38ef7d;
        }

        .join-progress-item .status-text.banned {
            background: rgba(235, 51, 73, 0.2);
            color: #eb3349;
        }

        .join-progress-item .status-text.error {
            background: rgba(235, 51, 73, 0.2);
            color: #eb3349;
        }

        .debug-toggle {
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .button-group {
                flex-direction: column;
            }
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Simple Chat Client (Anti-Ban)</h1>

        <!-- Important Notice -->
        <div class="important-notice">
            <h3>‚ö†Ô∏è Instructions</h3>
            <ul>
                <li><strong>Step 1:</strong> Enable Background Mode</li>
                <li><strong>Step 2:</strong> Connect your IDs</li>
                <li><strong>Step 3:</strong> Type room name manually (room list may not work on this server)</li>
                <li><strong>Step 4:</strong> Join room and start sending messages</li>
            </ul>
        </div>

        <!-- IP/Device Section -->
        <div class="section">
            <h2>üõ°Ô∏è Device & IP Settings</h2>
            
            <div class="current-info">
                <div class="current-info-item">
                    <label>Current IP:</label>
                    <span id="currentIP">Checking...</span>
                </div>
                <div class="current-info-item">
                    <label>Device ID Pool:</label>
                    <span id="deviceIdCount">500+ combinations</span>
                </div>
            </div>

            <div class="form-group" style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="chkAutoChangeDevice" checked>
                    Auto-generate new Device ID when banned
                </label>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="chkDebugMode">
                    Show raw server messages (Debug Mode)
                </label>
            </div>

            <div class="form-group">
                <label>Join Delay Between IDs (ms):</label>
                <input type="number" id="joinDelay" value="5000" min="1000" step="1000">
                <span class="hint">Time to wait between joining each ID</span>
            </div>

            <div class="button-group">
                <button id="btnCheckIP" class="btn btn-small btn-secondary">Check IP</button>
                <button id="btnEnableBackground" class="btn btn-success">üîã Enable Background Mode</button>
            </div>
            
            <div id="backgroundStatus" class="status-bar hidden">
                <span class="keep-alive-status">‚óè Background Mode Active</span>
                <span id="lastPingTime">Last ping: --</span>
            </div>
        </div>

        <!-- Section 1: Connection -->
        <div class="section">
            <h2>1. Connect IDs</h2>
            <div class="form-group">
                <label>Enter IDs (separated by #, max 20):</label>
                <textarea id="inputIds" placeholder="id1#id2#id3#id4..." rows="3"></textarea>
            </div>
            <div class="form-group">
                <label>Password (same for all IDs):</label>
                <input type="password" id="inputPassword" placeholder="Enter password">
            </div>
            
            <div class="form-group">
                <label>Connection Delay (ms):</label>
                <input type="number" id="connectionDelay" value="2000" min="500" step="500">
            </div>

            <div class="button-group">
                <button id="btnConnect" class="btn btn-primary">Connect</button>
                <button id="btnDisconnect" class="btn btn-danger" disabled>Disconnect All</button>
            </div>
            
            <div class="status-bar">
                <span>
                    <span class="connection-indicator disconnected" id="mainIndicator"></span>
                    Connected: <strong id="connectedCount">0</strong> IDs
                </span>
                <span>In Room: <strong id="globalIdsInRoom">0</strong></span>
            </div>
            <div id="connectedIdsList" class="connected-ids-list"></div>
        </div>

        <!-- Section 2: Room -->
        <div class="section">
            <h2>2. Room Management</h2>
            
            <div class="form-group">
                <label>Room Name (type manually):</label>
                <input type="text" id="inputRoom" placeholder="Enter room name (e.g., american, lobby, etc.)">
            </div>
            
            <div class="form-group">
                <div class="room-list-header">
                    <label>Available Rooms (may not work):</label>
                    <button id="btnFetchRooms" class="btn btn-small btn-secondary" disabled>Fetch Rooms</button>
                </div>
                <select id="roomList" size="3">
                    <option value="" disabled>-- Type room name above --</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="btnJoinRoom" class="btn btn-primary" disabled>Join Room (One by One)</button>
                <button id="btnStopJoining" class="btn btn-orange hidden">Stop Joining</button>
                <button id="btnLeaveRoom" class="btn btn-warning" disabled>Leave Room</button>
            </div>
            
            <div id="currentRoomStatus" class="status-bar hidden">
                <span>Current Room: <strong id="currentRoom"></strong></span>
                <span>IDs in Room: <strong id="idsInRoomCount">0</strong></span>
                <span class="room-status" id="roomStatus">In Room</span>
            </div>

            <!-- Join Progress -->
            <div id="joinProgress" class="join-progress hidden">
                <h4 style="color: #a0a0ff; margin-bottom: 10px;">Join Progress:</h4>
                <div id="joinProgressList"></div>
            </div>
        </div>

        <!-- Section 3: Messages -->
        <div class="section">
            <h2>3. Messages</h2>
            
            <div class="form-group">
                <label>Messages to Send (one per line - will loop):</label>
                <textarea id="inputMessages" placeholder="Enter messages here, one per line...&#10;Message 1&#10;Message 2&#10;Message 3" rows="8"></textarea>
            </div>
            
            <div class="form-group">
                <label>Send Interval (ms):</label>
                <input type="number" id="messageInterval" value="3000" min="500" step="500">
                <span class="hint">Minimum 500ms</span>
            </div>
            
            <div class="button-group">
                <button id="btnStartLoop" class="btn btn-success">Start Sending</button>
                <button id="btnStopLoop" class="btn btn-danger" disabled>Stop Sending</button>
            </div>
            
            <div id="messageStatus" class="status-bar hidden">
                <span>Status: <strong id="loopStatus">Sending...</strong></span>
                <span>Sent: <strong id="messagesSentCount">0</strong></span>
            </div>
        </div>

        <!-- Section 4: Chat Display -->
        <div class="section">
            <h2>4. Room Chat</h2>
            <div class="chat-box" id="chatBox">
                <p class="placeholder-text">Join a room to see messages...</p>
            </div>
        </div>

        <!-- Section 5: Log -->
        <div class="section">
            <h2>üìã Activity Log</h2>
            <div class="log-box" id="logBox">
                <p class="info">Application started...</p>
            </div>
            <div class="button-group">
                <button id="btnClearLog" class="btn btn-secondary btn-small">Clear Log</button>
                <button id="btnExportLog" class="btn btn-secondary btn-small">Export Log</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== DEVICE ID GENERATOR (EXPANDED) ====================
        
        const DeviceGenerator = {
            manufacturers: [
                'Samsung', 'Google', 'OnePlus', 'Xiaomi', 'Huawei', 'Oppo', 'Vivo', 
                'Realme', 'Motorola', 'Nokia', 'Sony', 'LG', 'Asus', 'Lenovo', 'ZTE',
                'Meizu', 'Honor', 'Poco', 'Nothing', 'Tecno', 'Infinix', 'Redmi',
                'HTC', 'BlackBerry', 'Alcatel', 'TCL', 'Micromax', 'Lava', 'Karbonn',
                'Gionee', 'Coolpad', 'LeEco', 'Sharp', 'Panasonic', 'Philips', 'BLU',
                'Cubot', 'Umidigi', 'Doogee', 'Oukitel', 'Ulefone', 'Blackview', 'AGM',
                'CAT', 'Crosscall', 'Fairphone', 'Essential', 'Razer', 'ROG', 'RedMagic',
                'iQOO', 'Nubia', 'Xperia', 'Aquos', 'Arrows', 'Wiko', 'Energizer'
            ],
            
            models: {
                'Samsung': ['Galaxy S21', 'Galaxy S22', 'Galaxy S23', 'Galaxy S24', 'Galaxy A52', 'Galaxy A53', 'Galaxy A54', 'Galaxy A73', 'Galaxy Note20', 'Galaxy Note10', 'Galaxy Z Flip4', 'Galaxy Z Flip5', 'Galaxy Z Fold4', 'Galaxy Z Fold5', 'Galaxy M33', 'Galaxy M53', 'Galaxy F54', 'Galaxy A34', 'Galaxy A14', 'Galaxy S21 FE', 'Galaxy S20', 'Galaxy S10', 'Galaxy A72', 'Galaxy A32'],
                'Google': ['Pixel 4', 'Pixel 4a', 'Pixel 4 XL', 'Pixel 5', 'Pixel 5a', 'Pixel 6', 'Pixel 6a', 'Pixel 6 Pro', 'Pixel 7', 'Pixel 7a', 'Pixel 7 Pro', 'Pixel 8', 'Pixel 8 Pro', 'Pixel Fold'],
                'OnePlus': ['9', '9 Pro', '9R', '9RT', '10 Pro', '10T', '10R', '11', '11R', 'Nord', 'Nord 2', 'Nord 2T', 'Nord CE', 'Nord CE 2', 'Nord CE 3', 'Nord N20', 'Nord N30', '8', '8T', '8 Pro', '7T', '7 Pro'],
                'Xiaomi': ['Mi 11', 'Mi 11 Ultra', 'Mi 11i', 'Mi 12', 'Mi 12 Pro', 'Mi 12 Ultra', 'Mi 13', 'Mi 13 Pro', 'Mi 13 Ultra', 'Redmi Note 11', 'Redmi Note 12', 'Redmi Note 13', 'Redmi 12', 'Redmi 13C', 'Poco F4', 'Poco F5', 'Poco X4', 'Poco X5', 'Poco M5', 'Poco C55', 'Mi 10', 'Mi 10T', 'Mi 9'],
                'Huawei': ['P40', 'P40 Pro', 'P50', 'P50 Pro', 'P60', 'P60 Pro', 'Mate 40', 'Mate 40 Pro', 'Mate 50', 'Mate 50 Pro', 'Mate 60', 'Mate 60 Pro', 'Nova 9', 'Nova 10', 'Nova 11', 'Y9a', 'Y7a'],
                'Oppo': ['Find X5', 'Find X5 Pro', 'Find X6', 'Find X6 Pro', 'Find N2', 'Find N3', 'Reno 8', 'Reno 9', 'Reno 10', 'A96', 'A78', 'A58', 'F21 Pro', 'F23', 'K11'],
                'Vivo': ['X80', 'X80 Pro', 'X90', 'X90 Pro', 'X100', 'V25', 'V27', 'V29', 'Y35', 'Y56', 'Y78', 'T1 Pro', 'T2', 'iQOO 11', 'iQOO Neo 8'],
                'Realme': ['GT 2', 'GT 2 Pro', 'GT 3', 'GT Neo 3', 'GT Neo 5', '10 Pro', '11 Pro', 'Narzo 50', 'Narzo 60', 'C35', 'C53', 'C55', '9 Pro', '9i'],
                'Motorola': ['Edge 30', 'Edge 30 Pro', 'Edge 40', 'Edge 40 Pro', 'Moto G82', 'Moto G84', 'Moto G54', 'Moto G52', 'Razr 40', 'Razr 40 Ultra', 'ThinkPhone'],
                'Nokia': ['X30', 'X20', 'G60', 'G42', 'C32', 'C31', '5.4', '7.2', '8.3'],
                'Sony': ['Xperia 1 IV', 'Xperia 1 V', 'Xperia 5 IV', 'Xperia 5 V', 'Xperia 10 IV', 'Xperia 10 V', 'Xperia Pro-I'],
                'LG': ['Velvet', 'Wing', 'V60', 'V50', 'G8X', 'K92'],
                'Asus': ['ROG Phone 6', 'ROG Phone 7', 'ROG Phone 7 Ultimate', 'Zenfone 9', 'Zenfone 10'],
                'Lenovo': ['Legion Duel 2', 'Legion Y70', 'K14', 'K13'],
                'ZTE': ['Axon 40', 'Axon 50', 'Blade V40', 'Nubia Z50', 'RedMagic 8'],
                'Honor': ['Magic 4', 'Magic 5', 'Magic 6', '70', '90', 'X8', 'X9a', 'Play 7T'],
                'Poco': ['F4 GT', 'F5', 'F5 Pro', 'X4 Pro', 'X5', 'X5 Pro', 'M4 Pro', 'M5', 'M5s', 'C55'],
                'Nothing': ['Phone 1', 'Phone 2'],
                'Tecno': ['Phantom X2', 'Phantom V Fold', 'Camon 20', 'Spark 10', 'Pova 5'],
                'Infinix': ['Zero Ultra', 'Zero 30', 'Note 30', 'Hot 30', 'Smart 8'],
                'Redmi': ['Note 12', 'Note 12 Pro', 'Note 13', 'Note 13 Pro', 'K50', 'K60', 'A1', 'A2', '12C', '13C']
            },
            
            sdkVersions: [26, 27, 28, 29, 30, 31, 32, 33, 34],
            
            generate() {
                const manufacturer = this.manufacturers[Math.floor(Math.random() * this.manufacturers.length)];
                const modelList = this.models[manufacturer] || this.models['Samsung'];
                const model = modelList[Math.floor(Math.random() * modelList.length)];
                const sdk = this.sdkVersions[Math.floor(Math.random() * this.sdkVersions.length)];
                const buildNumber = Math.floor(Math.random() * 900) + 100;
                
                return {
                    manufacturer,
                    model,
                    sdk,
                    buildNumber,
                    deviceId: `${buildNumber}-${manufacturer}-${model.replace(/\s+/g, '_')}-${sdk}`,
                    androidId: this.generateAndroidId(),
                    imei: this.generateImei()
                };
            },
            
            generateAndroidId() {
                const chars = 'abcdef0123456789';
                let id = '';
                for (let i = 0; i < 16; i++) {
                    id += chars[Math.floor(Math.random() * chars.length)];
                }
                return id;
            },
            
            generateImei() {
                let imei = '';
                for (let i = 0; i < 15; i++) {
                    imei += Math.floor(Math.random() * 10);
                }
                return imei;
            }
        };

        // ==================== BACKGROUND KEEP-ALIVE ====================
        
        class BackgroundKeepAlive {
            constructor() {
                this.audioContext = null;
                this.oscillator = null;
                this.gainNode = null;
                this.isActive = false;
                this.pingInterval = null;
                this.onPing = null;
            }
            
            start(onPingCallback) {
                if (this.isActive) return true;
                this.onPing = onPingCallback;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.oscillator = this.audioContext.createOscillator();
                    this.oscillator.frequency.value = 1;
                    this.oscillator.type = 'sine';
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0.001;
                    this.oscillator.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                    this.oscillator.start();
                    
                    this.pingInterval = setInterval(() => {
                        if (this.onPing) this.onPing();
                    }, 10000);
                    
                    this.isActive = true;
                    return true;
                } catch (error) {
                    console.error('Background keep-alive error:', error);
                    return false;
                }
            }
            
            stop() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                try {
                    if (this.oscillator) this.oscillator.stop();
                    if (this.audioContext) this.audioContext.close();
                } catch(e) {}
                this.isActive = false;
            }
        }

        // ==================== CHAT CLIENT CLASS ====================
        
        class ChatClient {
            constructor(username, password, callbacks, deviceInfo) {
                this.URL = 'wss://chatp.net:5333/server';
                this.webSocket = null;
                this.userName = username;
                this.passWord = password;
                this.deviceInfo = deviceInfo || DeviceGenerator.generate();
                this.currentRoom = "";
                this.targetRoom = ""; // The room we're trying to join
                this.isConnected = false;
                this.isInRoom = false;
                this.joinConfirmed = false; // Explicit join confirmation
                this.isBanned = false;
                this.banReason = "";
                this.bannedBy = "";
                this.pingInterval = null;
                this.reconnectTimeout = null;
                this.retryCount = 0;
                this.isManualDisconnect = false;
                this.lastRoom = "";
                this.messageReceived = false; // Track if we received messages from room
                
                // Callbacks
                this.onLoginSuccess = callbacks.onLoginSuccess || (() => {});
                this.onLoginFailed = callbacks.onLoginFailed || (() => {});
                this.onDisconnect = callbacks.onDisconnect || (() => {});
                this.onMessage = callbacks.onMessage || (() => {});
                this.onRoomJoined = callbacks.onRoomJoined || (() => {});
                this.onRoomLeft = callbacks.onRoomLeft || (() => {});
                this.onRoomList = callbacks.onRoomList || (() => {});
                this.onLog = callbacks.onLog || (() => {});
                this.onReconnecting = callbacks.onReconnecting || (() => {});
                this.onBanned = callbacks.onBanned || (() => {});
                this.onRawMessage = callbacks.onRawMessage || (() => {});

                this.connect();
            }

            connect() {
                try {
                    if (this.webSocket) {
                        try { this.webSocket.close(); } catch(e) {}
                    }

                    this.webSocket = new WebSocket(this.URL);
                    
                    this.webSocket.onopen = () => this._onOpen();
                    this.webSocket.onclose = (e) => this._onClose(e);
                    this.webSocket.onmessage = (e) => this._onMsg(e);
                    this.webSocket.onerror = (e) => this._onError(e);

                } catch (error) {
                    this.onLog(`[${this.userName}] Connection error: ${error.message}`);
                    this._scheduleReconnect();
                }
            }

            disconnect() {
                this.isManualDisconnect = true;
                this.isConnected = false;
                this.isInRoom = false;
                this.joinConfirmed = false;
                this._clearTimers();

                if (this.webSocket) {
                    try { this.webSocket.close(); } catch (e) {}
                    this.webSocket = null;
                }
            }

            changeDeviceId() {
                this.deviceInfo = DeviceGenerator.generate();
                return this.deviceInfo;
            }

            _clearTimers() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
            }

            _scheduleReconnect() {
                if (this.isManualDisconnect || this.isBanned) return;

                const delay = Math.min(2000 * Math.pow(1.5, this.retryCount), 30000);
                this.retryCount++;
                this.onReconnecting(this.retryCount, delay);

                this.reconnectTimeout = setTimeout(() => {
                    if (!this.isManualDisconnect && !this.isBanned) {
                        this.connect();
                    }
                }, delay);
            }

            _onOpen() {
                this.onLog(`[${this.userName}] Connected to server`);
                this.login();
            }

            _onClose(event) {
                this.onLog(`[${this.userName}] Disconnected (code: ${event.code})`);
                this.isConnected = false;
                this.isInRoom = false;
                this.joinConfirmed = false;
                this._clearTimers();

                if (!this.isManualDisconnect && !this.isBanned) {
                    this.onDisconnect(true);
                    this._scheduleReconnect();
                } else {
                    this.onDisconnect(false);
                }
            }

            _onError(error) {
                this.onLog(`[${this.userName}] WebSocket error`);
            }

            _onMsg(event) {
                try {
                    const payload = event.data;
                    if (!payload || payload.length === 0) return;
                    
                    // Log raw message if debug mode
                    this.onRawMessage(this.userName, payload);
                    
                    const data = JSON.parse(payload);
                    this._handleParsedData(data);
                } catch (error) {}
            }

            _handleParsedData(data) {
                const handler = data.handler;
                const type = data.type;

                // ========== LOGIN EVENTS ==========
                if (handler === "login_event") {
                    if (type === "success") {
                        this.isConnected = true;
                        this.retryCount = 0;
                        this._startPingInterval();
                        this.onLog(`[${this.userName}] ‚úì Login successful`);
                        this.onLoginSuccess();
                    } else {
                        this.onLog(`[${this.userName}] ‚úó Login failed: ${data.reason || type}`);
                        if (data.reason === 'invalid_password' || data.reason === 'invalid_username') {
                            this.isManualDisconnect = true;
                        }
                        this.onLoginFailed(data.reason || type);
                    }
                }

                // ========== ROOM LIST ==========
                if (handler === "room_list" || handler === "rooms" || handler === "group_list") {
                    const rooms = data.rooms || data.groups || data.list || [];
                    this.onRoomList(rooms);
                }

                // ========== ROOM EVENTS ==========
                if (handler === "room_event" || handler === "group_event" || handler === "room") {
                    const room = data.room || data.name || data.group;
                    
                    // ===== JOIN SUCCESS DETECTION =====
                    // Method 1: Explicit join success
                    if (type === "join_success" || type === "joined" || type === "join" || 
                        type === "room_joined" || type === "enter" || type === "entered") {
                        this._handleJoinSuccess(room || this.targetRoom);
                    }
                    
                    // Method 2: Receiving member list means we're in the room
                    if (type === "members" || type === "member_list" || type === "users" || data.members) {
                        if (this.targetRoom && !this.joinConfirmed) {
                            this._handleJoinSuccess(this.targetRoom);
                        }
                    }
                    
                    // Method 3: Receiving a text message from the room we're trying to join
                    if (type === "text" || type === "message") {
                        const msgRoom = data.room || data.group;
                        if (msgRoom && msgRoom === this.targetRoom && !this.joinConfirmed) {
                            this._handleJoinSuccess(msgRoom);
                        }
                        this.onMessage(data.from, data.body || data.message || data.text, msgRoom);
                    }

                    // ===== LEAVE =====
                    if (type === "leave_success" || type === "left" || type === "leave") {
                        this.currentRoom = "";
                        this.lastRoom = "";
                        this.isInRoom = false;
                        this.joinConfirmed = false;
                        this.onLog(`[${this.userName}] Left room`);
                        this.onRoomLeft(room);
                    }

                    // ===== BAN DETECTION =====
                    if (type === "banned" || type === "ban" || type === "blocked" ||
                        (type === "error" && this._isBanError(data))) {
                        this._handleBan(data);
                    }

                    // ===== KICK DETECTION =====
                    if (type === "kicked" || type === "kick") {
                        this.isInRoom = false;
                        this.joinConfirmed = false;
                        this.onLog(`[${this.userName}] üë¢ Kicked from room`);
                    }

                    // ===== ERROR HANDLING =====
                    if (type === "error" || type === "join_error" || type === "fail" || type === "failed") {
                        const reason = data.reason || data.message || data.error || 'Unknown error';
                        this.onLog(`[${this.userName}] ‚ùå Error: ${reason}`);
                        
                        if (this._isBanError(data)) {
                            this._handleBan(data);
                        }
                    }

                    // ===== USER EVENTS =====
                    if (type === "user_joined" || type === "user_enter") {
                        this.onLog(`[${this.userName}] üë§ ${data.username || data.user} joined`);
                    }
                    if (type === "user_left" || type === "user_leave") {
                        this.onLog(`[${this.userName}] üë§ ${data.username || data.user} left`);
                    }
                }

                // ========== ADMIN EVENTS ==========
                if (handler === "room_admin" || handler === "admin") {
                    if ((type === "ban" || type === "banned") && 
                        (data.t_username === this.userName || data.username === this.userName || data.target === this.userName)) {
                        this._handleBan(data);
                    }
                }
            }

            _handleJoinSuccess(room) {
                if (this.joinConfirmed) return; // Already confirmed
                
                this.currentRoom = room;
                this.lastRoom = room;
                this.isInRoom = true;
                this.joinConfirmed = true;
                this.isBanned = false;
                this.onLog(`[${this.userName}] ‚úì IN ROOM: ${room}`);
                this.onRoomJoined(room);
            }

            _isBanError(data) {
                const reason = (data.reason || data.message || data.error || '').toLowerCase();
                return reason.includes('ban') || reason.includes('block') || 
                       reason.includes('forbidden') || reason.includes('not allowed');
            }

            _handleBan(data) {
                this.isBanned = true;
                this.isInRoom = false;
                this.joinConfirmed = false;
                this.banReason = data.reason || data.message || 'Banned';
                this.bannedBy = data.by || data.admin || data.from || 'Admin';
                this.onLog(`[${this.userName}] üö´ BANNED: ${this.banReason}`);
                this.onBanned(this.bannedBy, this.banReason);
            }

            _startPingInterval() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                this.pingInterval = setInterval(() => this.sendPing(), 15000);
            }
            
            sendPing() {
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send("");
                    return true;
                }
                return false;
            }

            login() {
                const payload = {
                    handler: "login",
                    id: this.keyGen(20),
                    username: this.userName,
                    password: this.passWord
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                }
            }

            requestRoomList() {
                // Try multiple handlers
                const handlers = ["room_list", "rooms", "group_list", "get_rooms"];
                
                handlers.forEach((h, index) => {
                    setTimeout(() => {
                        const payload = { handler: h, id: this.keyGen(20) };
                        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                            this.webSocket.send(JSON.stringify(payload));
                        }
                    }, index * 500);
                });
            }

            joinRoom(roomName) {
                if (this.isBanned) {
                    this.onLog(`[${this.userName}] Cannot join - banned`);
                    return false;
                }
                
                this.targetRoom = roomName;
                this.joinConfirmed = false;
                
                const payload = { 
                    handler: "room_join", 
                    id: this.keyGen(20), 
                    name: roomName 
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.currentRoom = roomName;
                    this.lastRoom = roomName;
                    return true;
                }
                return false;
            }

            leaveRoom(roomName) {
                const payload = { 
                    handler: "room_leave", 
                    id: this.keyGen(20), 
                    name: roomName || this.currentRoom 
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.isInRoom = false;
                    this.joinConfirmed = false;
                    this.currentRoom = "";
                    this.lastRoom = "";
                    return true;
                }
                return false;
            }

            sendMessage(roomName, message) {
                const payload = {
                    handler: "room_message",
                    id: this.keyGen(20, true),
                    room: roomName,
                    type: "text",
                    url: "",
                    body: message,
                    length: ""
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            isAlive() {
                return this.webSocket && this.webSocket.readyState === WebSocket.OPEN && this.isConnected;
            }
            
            canSendMessage() {
                // Multiple checks for ability to send
                return this.isAlive() && 
                       !this.isBanned && 
                       (this.isInRoom || this.joinConfirmed || this.currentRoom);
            }

            keyGen(keyLength, isMsgId = false) {
                let key = "";
                let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                if (isMsgId) characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ";
                for (let i = 0; i < keyLength; i++) {
                    key += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return key;
            }
        }

        // ==================== MAIN APPLICATION ====================
        
        // State
        let clients = new Map();
        let clientStates = new Map();
        let connectedIdsSet = new Set();
        let activeRoom = '';
        let messageLoopInterval = null;
        let isMessageLoopRunning = false;
        let messagesSent = 0;
        let isJoiningSequentially = false;
        let stopJoining = false;
        let idsInRoom = new Set();
        let bannedIds = new Set();
        let debugMode = false;
        
        const keepAlive = new BackgroundKeepAlive();

        // Elements
        const btnEnableBackground = document.getElementById('btnEnableBackground');
        const backgroundStatus = document.getElementById('backgroundStatus');
        const lastPingTime = document.getElementById('lastPingTime');
        const btnCheckIP = document.getElementById('btnCheckIP');
        const currentIPEl = document.getElementById('currentIP');
        const chkAutoChangeDevice = document.getElementById('chkAutoChangeDevice');
        const chkDebugMode = document.getElementById('chkDebugMode');
        const joinDelayInput = document.getElementById('joinDelay');

        const inputIds = document.getElementById('inputIds');
        const inputPassword = document.getElementById('inputPassword');
        const btnConnect = document.getElementById('btnConnect');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const connectedCount = document.getElementById('connectedCount');
        const connectedIdsList = document.getElementById('connectedIdsList');
        const connectionDelay = document.getElementById('connectionDelay');
        const mainIndicator = document.getElementById('mainIndicator');
        const globalIdsInRoomEl = document.getElementById('globalIdsInRoom');

        const inputRoom = document.getElementById('inputRoom');
        const roomList = document.getElementById('roomList');
        const btnFetchRooms = document.getElementById('btnFetchRooms');
        const btnJoinRoom = document.getElementById('btnJoinRoom');
        const btnStopJoining = document.getElementById('btnStopJoining');
        const btnLeaveRoom = document.getElementById('btnLeaveRoom');
        const currentRoomStatus = document.getElementById('currentRoomStatus');
        const currentRoomEl = document.getElementById('currentRoom');
        const idsInRoomCountEl = document.getElementById('idsInRoomCount');
        const roomStatus = document.getElementById('roomStatus');
        const joinProgress = document.getElementById('joinProgress');
        const joinProgressList = document.getElementById('joinProgressList');

        const inputMessages = document.getElementById('inputMessages');
        const messageInterval = document.getElementById('messageInterval');
        const btnStartLoop = document.getElementById('btnStartLoop');
        const btnStopLoop = document.getElementById('btnStopLoop');
        const messageStatus = document.getElementById('messageStatus');
        const loopStatusEl = document.getElementById('loopStatus');
        const messagesSentCount = document.getElementById('messagesSentCount');

        const chatBox = document.getElementById('chatBox');
        const logBox = document.getElementById('logBox');
        const btnClearLog = document.getElementById('btnClearLog');
        const btnExportLog = document.getElementById('btnExportLog');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            checkIP();
        });

        function setupEventListeners() {
            btnEnableBackground.addEventListener('click', enableBackgroundMode);
            btnCheckIP.addEventListener('click', checkIP);
            
            chkDebugMode.addEventListener('change', () => {
                debugMode = chkDebugMode.checked;
                addLog(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`, 'info');
            });
            
            btnConnect.addEventListener('click', connectIds);
            btnDisconnect.addEventListener('click', disconnectAll);
            btnFetchRooms.addEventListener('click', fetchRooms);
            
            roomList.addEventListener('change', () => {
                inputRoom.value = roomList.value;
            });
            
            btnJoinRoom.addEventListener('click', joinRoomSequentially);
            btnStopJoining.addEventListener('click', () => {
                stopJoining = true;
                btnStopJoining.classList.add('hidden');
                addLog('Stopping join process...', 'warning');
            });
            btnLeaveRoom.addEventListener('click', leaveRoom);
            btnStartLoop.addEventListener('click', startMessageLoop);
            btnStopLoop.addEventListener('click', stopMessageLoop);
            
            btnClearLog.addEventListener('click', () => {
                logBox.innerHTML = '<p class="info">Log cleared</p>';
            });
            
            btnExportLog.addEventListener('click', exportLog);
        }

        async function checkIP() {
            currentIPEl.textContent = 'Checking...';
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                currentIPEl.textContent = data.ip;
                addLog(`Current IP: ${data.ip}`, 'info');
            } catch (error) {
                currentIPEl.textContent = 'Unknown';
            }
        }

        function enableBackgroundMode() {
            const success = keepAlive.start(() => {
                const now = new Date().toLocaleTimeString();
                lastPingTime.textContent = `Last ping: ${now}`;
                
                clients.forEach((client) => {
                    if (client.isAlive()) client.sendPing();
                });
            });
            
            if (success) {
                btnEnableBackground.textContent = '‚úì Background Mode Active';
                btnEnableBackground.disabled = true;
                btnEnableBackground.style.background = '#3a3a5a';
                backgroundStatus.classList.remove('hidden');
                addLog('Background mode enabled', 'success');
            }
        }

        function createClient(username, password) {
            return new Promise((resolve) => {
                const deviceInfo = DeviceGenerator.generate();
                
                const timeout = setTimeout(() => {
                    clientStates.set(username, 'failed');
                    updateIdTagState(username, 'failed');
                    resolve({ username, success: false, message: 'Timeout' });
                }, 20000);

                const callbacks = {
                    onLoginSuccess: () => {
                        clearTimeout(timeout);
                        connectedIdsSet.add(username);
                        clientStates.set(username, 'connected');
                        updateIdTagState(username, 'connected', deviceInfo.deviceId);
                        updateConnectionUI();
                        resolve({ username, success: true, deviceId: deviceInfo.deviceId });
                    },
                    onLoginFailed: (error) => {
                        clearTimeout(timeout);
                        clientStates.set(username, 'failed');
                        updateIdTagState(username, 'failed');
                        resolve({ username, success: false, message: error });
                    },
                    onDisconnect: (willReconnect) => {
                        if (!willReconnect) {
                            connectedIdsSet.delete(username);
                            idsInRoom.delete(username);
                            clientStates.delete(username);
                            updateConnectionUI();
                            updateRoomCount();
                        }
                    },
                    onMessage: (from, message, room) => {
                        addChatMessage(from, message, room);
                        
                        // If we receive a message from our target room, we're definitely in
                        const client = clients.get(username);
                        if (client && room === client.targetRoom && !client.joinConfirmed) {
                            client.joinConfirmed = true;
                            client.isInRoom = true;
                            idsInRoom.add(username);
                            updateIdTagState(username, 'in-room', client.deviceInfo?.deviceId);
                            updateRoomCount();
                        }
                    },
                    onRoomJoined: (room) => {
                        idsInRoom.add(username);
                        updateIdTagState(username, 'in-room', clients.get(username)?.deviceInfo?.deviceId);
                        updateRoomCount();
                        activeRoom = room;
                        updateRoomStatusUI();
                    },
                    onRoomLeft: (room) => {
                        idsInRoom.delete(username);
                        updateIdTagState(username, 'connected', clients.get(username)?.deviceInfo?.deviceId);
                        updateRoomCount();
                    },
                    onRoomList: (rooms) => {
                        updateRoomListUI(rooms);
                    },
                    onLog: (msg) => {
                        addLog(msg);
                    },
                    onReconnecting: (attempt) => {
                        clientStates.set(username, 'reconnecting');
                        updateIdTagState(username, 'reconnecting', null, attempt);
                    },
                    onBanned: (bannedBy, reason) => {
                        bannedIds.add(username);
                        idsInRoom.delete(username);
                        clientStates.set(username, 'banned');
                        updateIdTagState(username, 'banned');
                        updateRoomCount();
                        addLog(`üö´ ${username} BANNED by ${bannedBy}: ${reason}`, 'ban');
                    },
                    onRawMessage: (user, raw) => {
                        if (debugMode) {
                            addLog(`[RAW ${user}] ${raw.substring(0, 200)}...`, 'raw');
                        }
                    }
                };

                const client = new ChatClient(username, password, callbacks, deviceInfo);
                clients.set(username, client);
                clientStates.set(username, 'connecting');
            });
        }

        function updateIdTagState(username, state, deviceId = null, retryCount = 0) {
            const tag = document.getElementById(`tag-${username}`);
            if (!tag) return;
            
            tag.className = 'connected-id-tag';
            
            const client = clients.get(username);
            const devId = deviceId || client?.deviceInfo?.deviceId || '';
            const shortDevId = devId ? devId.substring(0, 20) : '';
            
            let content = username;
            
            switch(state) {
                case 'connecting':
                    tag.classList.add('connecting');
                    content = `‚è≥ ${username}`;
                    break;
                case 'reconnecting':
                    tag.classList.add('reconnecting');
                    content = `üîÑ ${username}`;
                    break;
                case 'failed':
                    tag.classList.add('failed');
                    content = `‚ùå ${username}`;
                    break;
                case 'banned':
                    tag.classList.add('banned');
                    content = `üö´ ${username}`;
                    break;
                case 'in-room':
                    tag.classList.add('in-room');
                    content = `‚úì ${username} <span class="device-id-display">[IN ROOM]</span>`;
                    break;
                case 'connected':
                default:
                    content = `‚úì ${username}`;
                    break;
            }
            
            tag.innerHTML = content;
        }

        function updateRoomCount() {
            idsInRoomCountEl.textContent = idsInRoom.size;
            globalIdsInRoomEl.textContent = idsInRoom.size;
        }

        async function connectIds() {
            const idsText = inputIds.value.trim();
            const password = inputPassword.value.trim();
            
            if (!idsText || !password) {
                addLog('Please enter IDs and password', 'error');
                return;
            }
            
            const ids = idsText.split('#').map(id => id.trim()).filter(id => id);
            
            if (ids.length === 0 || ids.length > 20) {
                addLog('Enter 1-20 valid IDs', 'error');
                return;
            }
            
            if (!keepAlive.isActive) enableBackgroundMode();
            
            const delay = parseInt(connectionDelay.value) || 2000;
            
            btnConnect.disabled = true;
            btnConnect.textContent = 'Connecting...';
            
            connectedIdsList.innerHTML = '';
            ids.forEach(id => {
                const tag = document.createElement('span');
                tag.className = 'connected-id-tag connecting';
                tag.id = `tag-${id}`;
                tag.innerHTML = `‚è≥ ${id}`;
                connectedIdsList.appendChild(tag);
            });
            
            addLog(`Connecting ${ids.length} IDs...`, 'info');
            
            for (const id of ids) {
                if (clients.has(id) && clients.get(id).isAlive()) {
                    updateIdTagState(id, 'connected');
                    continue;
                }
                
                const result = await createClient(id, password);
                addLog(`${id}: ${result.success ? 'Connected' : 'Failed'}`, result.success ? 'success' : 'error');
                
                await new Promise(r => setTimeout(r, delay));
            }
            
            addLog(`Done. Connected: ${connectedIdsSet.size}`, 'success');
            
            if (connectedIdsSet.size > 0) {
                btnDisconnect.disabled = false;
                btnFetchRooms.disabled = false;
                btnJoinRoom.disabled = false;
            }
            
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect';
        }

        function updateConnectionUI() {
            connectedCount.textContent = connectedIdsSet.size;
            
            mainIndicator.className = 'connection-indicator';
            mainIndicator.classList.add(connectedIdsSet.size > 0 ? 'connected' : 'disconnected');
            
            btnDisconnect.disabled = connectedIdsSet.size === 0;
            btnFetchRooms.disabled = connectedIdsSet.size === 0;
            btnJoinRoom.disabled = connectedIdsSet.size === 0;
        }

        function disconnectAll() {
            stopMessageLoop();
            stopJoining = true;
            
            clients.forEach(c => c.disconnect());
            clients.clear();
            clientStates.clear();
            connectedIdsSet.clear();
            idsInRoom.clear();
            bannedIds.clear();
            
            activeRoom = '';
            messagesSent = 0;
            
            updateConnectionUI();
            updateRoomCount();
            
            connectedIdsList.innerHTML = '';
            currentRoomStatus.classList.add('hidden');
            messageStatus.classList.add('hidden');
            joinProgress.classList.add('hidden');
            
            addLog('All disconnected', 'info');
        }

        function fetchRooms() {
            if (connectedIdsSet.size === 0) return;
            
            btnFetchRooms.textContent = 'Fetching...';
            
            let found = false;
            clients.forEach(c => {
                if (c.isAlive() && !found) {
                    c.requestRoomList();
                    found = true;
                }
            });
            
            addLog('Fetching rooms... (may not work on this server)', 'info');
            
            setTimeout(() => {
                btnFetchRooms.textContent = 'Fetch Rooms';
            }, 3000);
        }

        function updateRoomListUI(rooms) {
            roomList.innerHTML = '';
            
            if (rooms && rooms.length > 0) {
                rooms.forEach(room => {
                    const option = document.createElement('option');
                    const roomName = typeof room === 'string' ? room : (room.name || room.room || '');
                    if (roomName) {
                        option.value = roomName;
                        option.textContent = roomName;
                        roomList.appendChild(option);
                    }
                });
                addLog(`Found ${rooms.length} rooms`, 'success');
            } else {
                roomList.innerHTML = '<option value="" disabled>-- Type room name manually --</option>';
                addLog('No rooms found - type room name manually', 'warning');
            }
        }

        async function joinRoomSequentially() {
            const roomName = inputRoom.value.trim();
            
            if (!roomName) {
                addLog('Please enter room name', 'error');
                return;
            }
            
            if (connectedIdsSet.size === 0) {
                addLog('No IDs connected', 'error');
                return;
            }
            
            if (isJoiningSequentially) return;
            
            isJoiningSequentially = true;
            stopJoining = false;
            
            btnJoinRoom.disabled = true;
            btnStopJoining.classList.remove('hidden');
            
            activeRoom = roomName;
            currentRoomEl.textContent = roomName;
            currentRoomStatus.classList.remove('hidden');
            roomStatus.textContent = 'Joining...';
            roomStatus.style.background = '#ffc107';
            
            joinProgress.classList.remove('hidden');
            joinProgressList.innerHTML = '';
            chatBox.innerHTML = '';
            
            const delay = parseInt(joinDelayInput.value) || 5000;
            const clientArray = Array.from(clients.entries());
            
            addLog(`Joining ${roomName} (${clientArray.length} IDs, ${delay}ms delay)`, 'info');
            
            for (let i = 0; i < clientArray.length; i++) {
                if (stopJoining) break;
                
                const [username, client] = clientArray[i];
                
                // Add progress item
                const progressItem = document.createElement('div');
                progressItem.className = 'join-progress-item';
                progressItem.id = `progress-${username}`;
                progressItem.innerHTML = `
                    <span class="status-icon">‚è≥</span>
                    <span class="username">${username}</span>
                    <span class="status-text joining">Joining...</span>
                `;
                joinProgressList.appendChild(progressItem);
                
                if (!client.isAlive()) {
                    updateProgressItem(username, '‚ùå', 'Not connected', 'error');
                    continue;
                }
                
                if (client.isBanned) {
                    if (chkAutoChangeDevice.checked) {
                        client.changeDeviceId();
                        client.isBanned = false;
                    } else {
                        updateProgressItem(username, 'üö´', 'Banned', 'banned');
                        continue;
                    }
                }
                
                // Reset join state
                client.joinConfirmed = false;
                client.isInRoom = false;
                client.targetRoom = roomName;
                
                // Join room
                client.joinRoom(roomName);
                
                // Wait for join result
                const result = await waitForJoinResult(username, 8000);
                
                if (result.success) {
                    updateProgressItem(username, '‚úì', 'In Room', 'joined');
                    idsInRoom.add(username);
                    updateRoomCount();
                } else if (result.banned) {
                    updateProgressItem(username, 'üö´', 'Banned', 'banned');
                    
                    if (chkAutoChangeDevice.checked && i < clientArray.length - 1) {
                        addLog('‚ö†Ô∏è Consider changing VPN/IP before next ID', 'warning');
                        for (let j = i + 1; j < clientArray.length; j++) {
                            clientArray[j][1].changeDeviceId();
                        }
                    }
                } else {
                    // Even if timeout, check if we're actually in room
                    if (client.isInRoom || client.joinConfirmed) {
                        updateProgressItem(username, '‚úì', 'In Room', 'joined');
                        idsInRoom.add(username);
                        updateRoomCount();
                    } else {
                        updateProgressItem(username, '‚ö†Ô∏è', 'Unknown', 'waiting');
                        // Still add to room - might be in
                        client.isInRoom = true;
                        client.joinConfirmed = true;
                        idsInRoom.add(username);
                        updateRoomCount();
                    }
                }
                
                if (i < clientArray.length - 1 && !stopJoining) {
                    await new Promise(r => setTimeout(r, delay));
                }
            }
            
            isJoiningSequentially = false;
            btnJoinRoom.disabled = false;
            btnStopJoining.classList.add('hidden');
            
            if (idsInRoom.size > 0) {
                btnLeaveRoom.disabled = false;
                roomStatus.textContent = 'In Room';
                roomStatus.style.background = '#38ef7d';
            } else {
                roomStatus.textContent = 'Check status';
                roomStatus.style.background = '#ffc107';
            }
            
            updateRoomCount();
            addLog(`Join complete. ${idsInRoom.size} IDs in room`, 'success');
        }

        function updateProgressItem(username, icon, status, statusClass) {
            const item = document.getElementById(`progress-${username}`);
            if (item) {
                item.querySelector('.status-icon').textContent = icon;
                const statusEl = item.querySelector('.status-text');
                statusEl.textContent = status;
                statusEl.className = `status-text ${statusClass}`;
            }
        }

        function waitForJoinResult(username, timeout) {
            return new Promise((resolve) => {
                const client = clients.get(username);
                if (!client) {
                    resolve({ success: false, reason: 'No client' });
                    return;
                }
                
                const startTime = Date.now();
                const checkInterval = setInterval(() => {
                    // Check various success indicators
                    if (client.joinConfirmed || client.isInRoom) {
                        clearInterval(checkInterval);
                        resolve({ success: true });
                    } else if (client.isBanned) {
                        clearInterval(checkInterval);
                        resolve({ success: false, banned: true, reason: client.banReason });
                    } else if (Date.now() - startTime > timeout) {
                        clearInterval(checkInterval);
                        // Final check
                        if (client.isInRoom || client.joinConfirmed || client.currentRoom) {
                            resolve({ success: true });
                        } else {
                            resolve({ success: false, reason: 'Timeout' });
                        }
                    }
                }, 300);
            });
        }

        function leaveRoom() {
            if (!activeRoom) return;
            
            stopMessageLoop();
            
            clients.forEach(c => {
                if (c.isAlive()) c.leaveRoom(activeRoom);
            });
            
            idsInRoom.clear();
            roomStatus.textContent = 'Left';
            roomStatus.style.background = '#eb3349';
            
            addLog(`Left room: ${activeRoom}`, 'info');
            activeRoom = '';
            
            setTimeout(() => {
                currentRoomStatus.classList.add('hidden');
                joinProgress.classList.add('hidden');
            }, 2000);
            
            btnLeaveRoom.disabled = true;
            updateRoomCount();
        }

        function updateRoomStatusUI() {
            if (activeRoom) {
                currentRoomEl.textContent = activeRoom;
                currentRoomStatus.classList.remove('hidden');
                btnLeaveRoom.disabled = false;
            }
        }

        function startMessageLoop() {
            const messagesText = inputMessages.value.trim();
            
            if (!messagesText) {
                addLog('Please enter messages', 'error');
                return;
            }
            
            if (!activeRoom) {
                addLog('Please join a room first', 'error');
                return;
            }
            
            // Check if any client can send
            let canSend = false;
            clients.forEach(c => {
                if (c.canSendMessage() || c.isInRoom || c.joinConfirmed || c.currentRoom === activeRoom) {
                    canSend = true;
                }
            });
            
            if (!canSend) {
                addLog('No IDs can send messages. Trying anyway...', 'warning');
            }
            
            const messages = messagesText.split('\n').map(m => m.trim()).filter(m => m);
            
            if (messages.length === 0) {
                addLog('No valid messages', 'error');
                return;
            }
            
            const interval = Math.max(500, parseInt(messageInterval.value) || 3000);
            
            isMessageLoopRunning = true;
            messagesSent = 0;
            let messageIndex = 0;
            
            const sendNextMessage = () => {
                if (!isMessageLoopRunning) return;
                
                const message = messages[messageIndex % messages.length];
                let count = 0;
                
                clients.forEach((client) => {
                    // Try to send if client is alive and has any indication of being in room
                    if (client.isAlive() && !client.isBanned && 
                        (client.isInRoom || client.joinConfirmed || client.currentRoom === activeRoom || idsInRoom.has(client.userName))) {
                        const sent = client.sendMessage(activeRoom, message);
                        if (sent) count++;
                    }
                });
                
                if (count > 0) {
                    messagesSent++;
                    messagesSentCount.textContent = messagesSent;
                } else {
                    addLog(`Warning: Message may not have been sent (0 clients ready)`, 'warning');
                }
                
                messageIndex++;
            };
            
            sendNextMessage();
            messageLoopInterval = setInterval(sendNextMessage, interval);
            
            btnStartLoop.disabled = true;
            btnStopLoop.disabled = false;
            messageStatus.classList.remove('hidden');
            loopStatusEl.textContent = 'Sending...';
            loopStatusEl.classList.add('sending-active');
            
            addLog(`Started: ${messages.length} messages, ${interval}ms interval`, 'success');
        }

        function stopMessageLoop() {
            isMessageLoopRunning = false;
            
            if (messageLoopInterval) {
                clearInterval(messageLoopInterval);
                messageLoopInterval = null;
            }
            
            btnStartLoop.disabled = false;
            btnStopLoop.disabled = true;
            loopStatusEl.textContent = 'Stopped';
            loopStatusEl.classList.remove('sending-active');
            
            if (messagesSent > 0) {
                addLog('Message loop stopped', 'info');
            }
        }

        function addChatMessage(from, message, room) {
            const placeholder = chatBox.querySelector('.placeholder-text');
            if (placeholder) placeholder.remove();
            
            const time = new Date().toLocaleTimeString();
            const isOwn = connectedIdsSet.has(from);
            
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
            msgDiv.innerHTML = `
                <div class="from">${escapeHtml(from)}</div>
                <div class="text">${escapeHtml(message)}</div>
                <div class="time">${time}</div>
            `;
            
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            while (chatBox.children.length > 100) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }

        function addLog(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const p = document.createElement('p');
            p.className = type;
            p.textContent = `[${time}] ${message}`;
            logBox.appendChild(p);
            logBox.scrollTop = logBox.scrollHeight;
            
            while (logBox.children.length > 500) {
                logBox.removeChild(logBox.firstChild);
            }
        }

        function exportLog() {
            const logs = [];
            logBox.querySelectorAll('p').forEach(p => logs.push(p.textContent));
            
            const blob = new Blob([logs.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-log-${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>