<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #667eea;
        }

        h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #a0a0ff;
            border-bottom: 1px solid #3a3a5a;
            padding-bottom: 8px;
        }

        .section {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a5a;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.95rem;
        }

        input[type="number"] {
            width: 150px;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            line-height: 1.5;
        }

        textarea#inputMessages {
            min-height: 150px;
            font-size: 0.95rem;
        }

        select {
            cursor: pointer;
        }

        select option {
            padding: 8px;
            background: #1a1a2e;
        }

        .hint {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #ccc;
        }

        .radio-label input[type="radio"],
        .radio-label input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .room-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .room-list-header label {
            margin-bottom: 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #ccc;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4a4a6a;
        }

        .btn-orange {
            background: linear-gradient(135deg, #f5af19 0%, #f12711 100%);
            color: white;
        }

        .status-bar {
            margin-top: 15px;
            padding: 12px 15px;
            background: rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-bar strong {
            color: #38ef7d;
        }

        .room-status {
            background: #38ef7d;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .keep-alive-status {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            background: rgba(56, 239, 125, 0.2);
            color: #38ef7d;
        }

        .connected-ids-list {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .connected-id-tag {
            background: rgba(56, 239, 125, 0.2);
            border: 1px solid #38ef7d;
            color: #38ef7d;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .connected-id-tag.connecting {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffc107;
        }

        .connected-id-tag.reconnecting {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            color: #ffa500;
        }

        .connected-id-tag.failed {
            background: rgba(235, 51, 73, 0.2);
            border-color: #eb3349;
            color: #eb3349;
        }

        .connected-id-tag.banned {
            background: rgba(139, 0, 0, 0.3);
            border-color: #8b0000;
            color: #ff6b6b;
        }

        .connected-id-tag.in-room {
            background: rgba(56, 239, 125, 0.3);
            border-color: #38ef7d;
        }

        .retry-badge {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .device-id-display {
            font-size: 0.7rem;
            color: #888;
            margin-left: 5px;
        }

        .chat-box {
            height: 250px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #3a3a5a;
        }

        .chat-box .placeholder-text {
            color: #555;
            text-align: center;
            font-style: italic;
        }

        .chat-message {
            padding: 10px 14px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .chat-message.own {
            background: rgba(56, 239, 125, 0.1);
            border-left-color: #38ef7d;
        }

        .chat-message .from {
            font-weight: 600;
            color: #667eea;
            font-size: 0.85rem;
        }

        .chat-message.own .from {
            color: #38ef7d;
        }

        .chat-message .text {
            margin-top: 5px;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .chat-message .time {
            font-size: 0.7rem;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .log-box {
            height: 200px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            border: 1px solid #3a3a5a;
        }

        .log-box p {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .log-box .success {
            background: rgba(56, 239, 125, 0.1);
            color: #38ef7d;
        }

        .log-box .error {
            background: rgba(235, 51, 73, 0.1);
            color: #eb3349;
        }

        .log-box .info {
            background: rgba(102, 126, 234, 0.1);
            color: #a0a0ff;
        }

        .log-box .warning {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
        }

        .log-box .ban {
            background: rgba(139, 0, 0, 0.2);
            color: #ff6b6b;
            font-weight: bold;
        }

        .log-box .event {
            background: rgba(138, 43, 226, 0.1);
            color: #da70d6;
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sending-active {
            animation: pulse 1s infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .reconnecting-icon {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .connection-indicator.connected {
            background: #38ef7d;
        }

        .connection-indicator.disconnected {
            background: #eb3349;
        }

        .connection-indicator.connecting {
            background: #ffc107;
            animation: pulse 0.5s infinite;
        }

        .important-notice {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .important-notice h3 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .important-notice ul {
            margin-left: 20px;
            color: #ccc;
        }

        .important-notice li {
            margin-bottom: 5px;
        }

        .important-notice code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            color: #38ef7d;
        }

        .ip-section {
            background: rgba(235, 51, 73, 0.1);
            border: 1px solid #eb3349;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .ip-section h4 {
            color: #eb3349;
            margin-bottom: 10px;
        }

        .current-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .current-info-item {
            display: flex;
            flex-direction: column;
        }

        .current-info-item label {
            font-size: 0.75rem;
            color: #888;
        }

        .current-info-item span {
            font-family: monospace;
            color: #38ef7d;
        }

        .join-progress {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .join-progress-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #3a3a5a;
        }

        .join-progress-item:last-child {
            border-bottom: none;
        }

        .join-progress-item .status-icon {
            width: 20px;
            text-align: center;
        }

        .join-progress-item .username {
            flex: 1;
            font-weight: 500;
        }

        .join-progress-item .device-id {
            font-size: 0.75rem;
            color: #888;
            font-family: monospace;
        }

        .join-progress-item .status-text {
            font-size: 0.85rem;
            padding: 2px 8px;
            border-radius: 4px;
        }

        .join-progress-item .status-text.waiting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .join-progress-item .status-text.joining {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        .join-progress-item .status-text.joined {
            background: rgba(56, 239, 125, 0.2);
            color: #38ef7d;
        }

        .join-progress-item .status-text.banned {
            background: rgba(235, 51, 73, 0.2);
            color: #eb3349;
        }

        .join-progress-item .status-text.error {
            background: rgba(235, 51, 73, 0.2);
            color: #eb3349;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .button-group {
                flex-direction: column;
            }
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Simple Chat Client (Anti-Ban)</h1>

        <!-- Important Notice -->
        <div class="important-notice">
            <h3>‚ö†Ô∏è Anti-Ban Features</h3>
            <ul>
                <li><strong>Random Device ID:</strong> Each ID gets a unique random device ID</li>
                <li><strong>Ban Detection:</strong> Automatically detects bans and logs who banned you</li>
                <li><strong>Sequential Room Join:</strong> Joins IDs one by one with configurable delay</li>
                <li><strong>Auto Device ID Change:</strong> If banned, next ID uses new device ID</li>
                <li><strong>IP Change Required:</strong> You must manually change IP via VPN between bans</li>
            </ul>
        </div>

        <!-- IP/Device Section -->
        <div class="section">
            <h2>üõ°Ô∏è Device & IP Settings</h2>
            
            <div class="ip-section">
                <h4>‚ö†Ô∏è IP Address Issue</h4>
                <p style="color: #ccc; font-size: 0.9rem; margin-bottom: 10px;">
                    Browser cannot change your IP. You must change it manually:
                </p>
                <ul style="color: #aaa; font-size: 0.85rem; margin-left: 20px;">
                    <li>Disconnect and reconnect VPN to get new IP</li>
                    <li>Use different VPN server locations</li>
                    <li>If ExpressVPN doesn't work, try: NordVPN, Surfshark, or free VPNs</li>
                    <li>Some VPNs block WebSocket - try different protocols (OpenVPN, IKEv2)</li>
                </ul>
                <button id="btnCheckIP" class="btn btn-small btn-secondary" style="margin-top: 10px;">Check Current IP</button>
            </div>

            <div class="current-info">
                <div class="current-info-item">
                    <label>Current IP:</label>
                    <span id="currentIP">Checking...</span>
                </div>
                <div class="current-info-item">
                    <label>Device ID Pool Size:</label>
                    <span id="deviceIdCount">Unlimited (Random)</span>
                </div>
            </div>

            <div class="form-group" style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="chkAutoChangeDevice" checked>
                    Auto-generate new Device ID when banned
                </label>
            </div>

            <div class="form-group">
                <label>Join Delay Between IDs (ms):</label>
                <input type="number" id="joinDelay" value="5000" min="1000" step="1000">
                <span class="hint">Time to wait between joining each ID (recommended: 5000+)</span>
            </div>

            <button id="btnEnableBackground" class="btn btn-success" style="width: 100%; margin-top: 10px;">
                üîã Enable Background Mode (Required for Minimized Tab)
            </button>
            <div id="backgroundStatus" class="status-bar hidden">
                <span class="keep-alive-status" id="keepAliveStatus">‚óè Background Mode Active</span>
                <span id="lastPingTime">Last ping: --</span>
            </div>
        </div>

        <!-- Section 1: Connection -->
        <div class="section">
            <h2>1. Connect IDs</h2>
            <div class="form-group">
                <label>Enter IDs (separated by #, max 20):</label>
                <textarea id="inputIds" placeholder="id1#id2#id3#id4..." rows="3"></textarea>
            </div>
            <div class="form-group">
                <label>Password (same for all IDs):</label>
                <input type="password" id="inputPassword" placeholder="Enter password">
            </div>
            
            <div class="form-group">
                <label>Connection Mode:</label>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="sequential" checked>
                        <span>Connect One by One (Recommended)</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="all">
                        <span>Connect All at Once</span>
                    </label>
                </div>
            </div>
            
            <div class="form-group" id="delayGroup">
                <label>Delay between connections (ms):</label>
                <input type="number" id="connectionDelay" value="2000" min="500" step="500">
            </div>

            <div class="button-group">
                <button id="btnConnect" class="btn btn-primary">Connect</button>
                <button id="btnDisconnect" class="btn btn-danger" disabled>Disconnect All</button>
            </div>
            
            <div class="status-bar">
                <span>
                    <span class="connection-indicator disconnected" id="mainIndicator"></span>
                    Connected: <strong id="connectedCount">0</strong> IDs
                </span>
                <span id="reconnectStatus"></span>
            </div>
            <div id="connectedIdsList" class="connected-ids-list"></div>
        </div>

        <!-- Section 2: Room -->
        <div class="section">
            <h2>2. Room Management (Sequential Join)</h2>
            
            <div class="form-group">
                <label>Room Name:</label>
                <input type="text" id="inputRoom" placeholder="Enter room name or select from list below">
            </div>
            
            <div class="form-group">
                <div class="room-list-header">
                    <label>Available Rooms:</label>
                    <button id="btnFetchRooms" class="btn btn-small btn-secondary" disabled>Fetch Rooms</button>
                </div>
                <select id="roomList" size="5">
                    <option value="" disabled>-- Click "Fetch Rooms" to load --</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="btnJoinRoom" class="btn btn-primary" disabled>Join Room (One by One)</button>
                <button id="btnStopJoining" class="btn btn-orange hidden">Stop Joining</button>
                <button id="btnLeaveRoom" class="btn btn-warning" disabled>Leave Room</button>
            </div>
            
            <div id="currentRoomStatus" class="status-bar hidden">
                <span>Current Room: <strong id="currentRoom"></strong></span>
                <span>In Room: <strong id="idsInRoomCount">0</strong></span>
                <span class="room-status" id="roomStatus">In Room</span>
            </div>

            <!-- Join Progress -->
            <div id="joinProgress" class="join-progress hidden">
                <h4 style="color: #a0a0ff; margin-bottom: 10px;">Join Progress:</h4>
                <div id="joinProgressList"></div>
            </div>
        </div>

        <!-- Section 3: Messages -->
        <div class="section">
            <h2>3. Messages</h2>
            
            <div class="form-group">
                <label>Messages to Send (one per line - will loop continuously):</label>
                <textarea id="inputMessages" placeholder="Enter messages here, one per line...&#10;Message 1&#10;Message 2&#10;Message 3&#10;&#10;These will be sent in a loop until you stop." rows="8"></textarea>
            </div>
            
            <div class="form-group">
                <label>Send Interval (ms):</label>
                <input type="number" id="messageInterval" value="3000" min="500" step="500">
                <span class="hint">Minimum 500ms between messages</span>
            </div>
            
            <div class="button-group">
                <button id="btnStartLoop" class="btn btn-success">Start Sending</button>
                <button id="btnStopLoop" class="btn btn-danger" disabled>Stop Sending</button>
            </div>
            
            <div id="messageStatus" class="status-bar hidden">
                <span>Status: <strong id="loopStatus">Sending...</strong></span>
                <span>Messages Sent: <strong id="messagesSentCount">0</strong></span>
            </div>
        </div>

        <!-- Section 4: Chat Display -->
        <div class="section">
            <h2>4. Room Chat</h2>
            <div class="chat-box" id="chatBox">
                <p class="placeholder-text">Join a room to see messages...</p>
            </div>
        </div>

        <!-- Section 5: Log -->
        <div class="section">
            <h2>üìã Room Events & Activity Log</h2>
            <div class="log-box" id="logBox">
                <p class="info">Application started...</p>
            </div>
            <div class="button-group">
                <button id="btnClearLog" class="btn btn-secondary btn-small">Clear Log</button>
                <button id="btnExportLog" class="btn btn-secondary btn-small">Export Log</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== DEVICE ID GENERATOR ====================
        
        const DeviceGenerator = {
            manufacturers: [
                'Samsung', 'Google', 'OnePlus', 'Xiaomi', 'Huawei', 'Oppo', 'Vivo', 
                'Realme', 'Motorola', 'Nokia', 'Sony', 'LG', 'Asus', 'Lenovo', 'ZTE',
                'Meizu', 'Honor', 'Poco', 'Nothing', 'Tecno', 'Infinix', 'Redmi'
            ],
            
            models: {
                'Samsung': ['Galaxy S21', 'Galaxy S22', 'Galaxy S23', 'Galaxy A52', 'Galaxy A73', 'Galaxy Note20', 'Galaxy Z Flip', 'Galaxy M33'],
                'Google': ['Pixel 4', 'Pixel 5', 'Pixel 6', 'Pixel 7', 'Pixel 6a', 'Pixel 7 Pro', 'Pixel 8'],
                'OnePlus': ['9 Pro', '10 Pro', '11', 'Nord 2', 'Nord CE', '8T', '9R'],
                'Xiaomi': ['Mi 11', 'Mi 12', 'Redmi Note 11', 'Redmi Note 12', 'Poco F4', 'Poco X4'],
                'Huawei': ['P40', 'P50', 'Mate 40', 'Nova 9', 'Y9a'],
                'Oppo': ['Find X5', 'Reno 8', 'A96', 'F21 Pro'],
                'Vivo': ['X80', 'V25', 'Y35', 'T1 Pro'],
                'Realme': ['GT 2', '9 Pro', 'Narzo 50', 'C35'],
                'Motorola': ['Edge 30', 'Moto G82', 'Moto G52'],
                'Nokia': ['X30', 'G60', 'C31'],
                'Sony': ['Xperia 1 IV', 'Xperia 5 IV', 'Xperia 10 IV'],
                'LG': ['Velvet', 'Wing', 'V60'],
                'Asus': ['ROG Phone 6', 'Zenfone 9'],
                'Lenovo': ['Legion Duel 2', 'K14'],
                'ZTE': ['Axon 40', 'Blade V40'],
                'Meizu': ['18s Pro', '18X'],
                'Honor': ['Magic 4', '70', 'X8'],
                'Poco': ['F4 GT', 'X4 Pro', 'M4 Pro'],
                'Nothing': ['Phone 1', 'Phone 2'],
                'Tecno': ['Phantom X2', 'Camon 19'],
                'Infinix': ['Zero Ultra', 'Note 12'],
                'Redmi': ['Note 12', 'K50', 'A1']
            },
            
            sdkVersions: [28, 29, 30, 31, 32, 33],
            
            generate() {
                const manufacturer = this.manufacturers[Math.floor(Math.random() * this.manufacturers.length)];
                const modelList = this.models[manufacturer] || ['Unknown'];
                const model = modelList[Math.floor(Math.random() * modelList.length)];
                const sdk = this.sdkVersions[Math.floor(Math.random() * this.sdkVersions.length)];
                const buildNumber = Math.floor(Math.random() * 900) + 100;
                
                return {
                    manufacturer,
                    model,
                    sdk,
                    buildNumber,
                    deviceId: `${buildNumber}-${manufacturer}-${model.replace(/\s+/g, '_')}-${sdk}`,
                    androidId: this.generateAndroidId()
                };
            },
            
            generateAndroidId() {
                const chars = 'abcdef0123456789';
                let id = '';
                for (let i = 0; i < 16; i++) {
                    id += chars[Math.floor(Math.random() * chars.length)];
                }
                return id;
            }
        };

        // ==================== BACKGROUND KEEP-ALIVE SYSTEM ====================
        
        class BackgroundKeepAlive {
            constructor() {
                this.audioContext = null;
                this.oscillator = null;
                this.gainNode = null;
                this.isActive = false;
                this.pingInterval = null;
                this.onPing = null;
            }
            
            start(onPingCallback) {
                if (this.isActive) return true;
                
                this.onPing = onPingCallback;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.oscillator = this.audioContext.createOscillator();
                    this.oscillator.frequency.value = 1;
                    this.oscillator.type = 'sine';
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0.001;
                    this.oscillator.connect(this.gainNode);
                    this.gainNode.connect(this.audioContext.destination);
                    this.oscillator.start();
                    
                    this.pingInterval = setInterval(() => {
                        if (this.onPing) this.onPing();
                    }, 10000);
                    
                    this.isActive = true;
                    return true;
                } catch (error) {
                    console.error('Failed to start background keep-alive:', error);
                    return false;
                }
            }
            
            stop() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                if (this.oscillator) {
                    try { this.oscillator.stop(); this.oscillator.disconnect(); } catch(e) {}
                }
                if (this.gainNode) {
                    try { this.gainNode.disconnect(); } catch(e) {}
                }
                if (this.audioContext) {
                    try { this.audioContext.close(); } catch(e) {}
                }
                this.isActive = false;
            }
        }

        // ==================== CHAT CLIENT CLASS ====================
        
        class ChatClient {
            constructor(username, password, callbacks, deviceInfo) {
                this.URL = 'wss://chatp.net:5333/server';
                this.webSocket = null;
                this.userName = username;
                this.passWord = password;
                this.deviceInfo = deviceInfo || DeviceGenerator.generate();
                this.currentRoom = "";
                this.isConnected = false;
                this.isInRoom = false;
                this.isBanned = false;
                this.banReason = "";
                this.bannedBy = "";
                this.pingInterval = null;
                this.reconnectTimeout = null;
                this.retryCount = 0;
                this.isManualDisconnect = false;
                this.lastRoom = "";
                this.baseReconnectDelay = 2000;
                this.maxReconnectDelay = 30000;
                
                this.onLoginSuccess = callbacks.onLoginSuccess || (() => {});
                this.onLoginFailed = callbacks.onLoginFailed || (() => {});
                this.onDisconnect = callbacks.onDisconnect || (() => {});
                this.onMessage = callbacks.onMessage || (() => {});
                this.onRoomJoined = callbacks.onRoomJoined || (() => {});
                this.onRoomLeft = callbacks.onRoomLeft || (() => {});
                this.onRoomList = callbacks.onRoomList || (() => {});
                this.onLog = callbacks.onLog || (() => {});
                this.onReconnecting = callbacks.onReconnecting || (() => {});
                this.onReconnected = callbacks.onReconnected || (() => {});
                this.onBanned = callbacks.onBanned || (() => {});
                this.onRoomEvent = callbacks.onRoomEvent || (() => {});
                this.onKicked = callbacks.onKicked || (() => {});

                this.connect();
            }

            connect() {
                try {
                    if (this.webSocket) {
                        try { this.webSocket.close(); } catch(e) {}
                    }

                    this.webSocket = new WebSocket(this.URL);
                    
                    this.webSocket.onopen = () => this._onOpen();
                    this.webSocket.onclose = (e) => this._onClose(e);
                    this.webSocket.onmessage = (e) => this._onMsg(e);
                    this.webSocket.onerror = (e) => this._onError(e);

                } catch (error) {
                    this.onLog(`[${this.userName}] Connection error: ${error.message}`);
                    this._scheduleReconnect();
                }
            }

            disconnect() {
                this.isManualDisconnect = true;
                this.isConnected = false;
                this.isInRoom = false;
                this._clearTimers();

                if (this.webSocket) {
                    try { this.webSocket.close(); } catch (e) {}
                    this.webSocket = null;
                }
            }

            changeDeviceId() {
                this.deviceInfo = DeviceGenerator.generate();
                this.onLog(`[${this.userName}] Changed Device ID to: ${this.deviceInfo.deviceId}`);
                return this.deviceInfo;
            }

            _clearTimers() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
            }

            _scheduleReconnect() {
                if (this.isManualDisconnect || this.isBanned) return;

                const delay = Math.min(
                    this.baseReconnectDelay * Math.pow(1.5, this.retryCount) + Math.random() * 1000,
                    this.maxReconnectDelay
                );

                this.retryCount++;
                this.onReconnecting(this.retryCount, delay);

                this.reconnectTimeout = setTimeout(() => {
                    if (!this.isManualDisconnect && !this.isBanned) {
                        this.connect();
                    }
                }, delay);
            }

            _onOpen() {
                this.onLog(`[${this.userName}] Socket opened (Device: ${this.deviceInfo.deviceId})`);
                this.login();
            }

            _onClose(event) {
                this.onLog(`[${this.userName}] Socket closed (code: ${event.code})`);
                this.isConnected = false;
                this.isInRoom = false;
                this._clearTimers();

                if (!this.isManualDisconnect && !this.isBanned) {
                    this.onDisconnect(true);
                    this._scheduleReconnect();
                } else {
                    this.onDisconnect(false);
                }
            }

            _onError(error) {
                this.onLog(`[${this.userName}] WebSocket error`);
            }

            _onMsg(event) {
                try {
                    const payload = event.data;
                    if (!payload || payload.length === 0) return;
                    
                    const parsedData = JSON.parse(payload);
                    this._handleParsedData(parsedData);
                } catch (error) {}
            }

            _handleParsedData(data) {
                // Log all room events
                if (data.handler === "room_event") {
                    this.onRoomEvent(this.userName, data);
                }

                // Login events
                if (data.handler === "login_event") {
                    if (data.type === "success") {
                        this.isConnected = true;
                        this.retryCount = 0;
                        this._startPingInterval();
                        this.onLog(`[${this.userName}] Login successful`);
                        
                        if (this.lastRoom && !this.isBanned) {
                            this.joinRoom(this.lastRoom);
                            this.onReconnected(this.lastRoom);
                        } else {
                            this.onLoginSuccess();
                        }
                    } else {
                        this.onLog(`[${this.userName}] Login failed: ${data.reason || data.type}`);
                        if (data.reason === 'invalid_password' || data.reason === 'invalid_username') {
                            this.isManualDisconnect = true;
                            this.onLoginFailed(data.reason || data.type);
                        } else {
                            this._scheduleReconnect();
                        }
                    }
                }

                // Room list
                if (data.handler === "room_list") {
                    if (data.rooms) {
                        this.onRoomList(data.rooms);
                    }
                }

                // Room events
                if (data.handler === "room_event") {
                    // Text message
                    if (data.type === "text") {
                        this.onMessage(data.from, data.body, data.room);
                    }

                    // Join success
                    if (data.type === "join_success" || data.type === "joined") {
                        const room = data.name || data.room;
                        this.currentRoom = room;
                        this.lastRoom = room;
                        this.isInRoom = true;
                        this.isBanned = false;
                        this.onLog(`[${this.userName}] ‚úì Joined room: ${room}`);
                        this.onRoomJoined(room);
                    }

                    // Leave success
                    if (data.type === "leave_success" || data.type === "left") {
                        const room = data.name || data.room || this.currentRoom;
                        this.currentRoom = "";
                        this.lastRoom = "";
                        this.isInRoom = false;
                        this.onLog(`[${this.userName}] Left room: ${room}`);
                        this.onRoomLeft(room);
                    }

                    // User joined notification
                    if (data.type === "user_joined") {
                        this.onLog(`[${this.userName}] üë§ User joined: ${data.username} (role: ${data.role || 'member'})`);
                    }

                    // User left notification
                    if (data.type === "user_left") {
                        this.onLog(`[${this.userName}] üë§ User left: ${data.username}`);
                    }

                    // Ban detection
                    if (data.type === "banned" || data.type === "ban" || 
                        (data.type === "error" && data.reason && data.reason.toLowerCase().includes('ban'))) {
                        this.isBanned = true;
                        this.isInRoom = false;
                        this.banReason = data.reason || 'Banned from room';
                        this.bannedBy = data.by || data.admin || data.from || 'Unknown';
                        this.onLog(`[${this.userName}] üö´ BANNED by ${this.bannedBy}: ${this.banReason}`);
                        this.onBanned(this.bannedBy, this.banReason);
                    }

                    // Kick detection
                    if (data.type === "kicked" || data.type === "kick") {
                        this.isInRoom = false;
                        const kickedBy = data.by || data.admin || data.from || 'Unknown';
                        const reason = data.reason || 'Kicked from room';
                        this.onLog(`[${this.userName}] üë¢ KICKED by ${kickedBy}: ${reason}`);
                        this.onKicked(kickedBy, reason);
                    }

                    // Role change
                    if (data.type === "role_changed" || data.type === "change_role") {
                        this.onLog(`[${this.userName}] üîÑ Role changed: ${data.username} -> ${data.role} (by ${data.by || 'admin'})`);
                    }

                    // Join error / ban error
                    if (data.type === "error" || data.type === "join_error") {
                        const reason = data.reason || data.message || 'Unknown error';
                        this.onLog(`[${this.userName}] ‚ùå Room error: ${reason}`);
                        
                        if (reason.toLowerCase().includes('ban') || 
                            reason.toLowerCase().includes('blocked') ||
                            reason.toLowerCase().includes('forbidden')) {
                            this.isBanned = true;
                            this.isInRoom = false;
                            this.banReason = reason;
                            this.onBanned('Room', reason);
                        }
                    }
                }

                // Admin events
                if (data.handler === "room_admin") {
                    this.onLog(`[${this.userName}] üõ°Ô∏è Admin action: ${JSON.stringify(data)}`);
                    
                    if (data.type === "ban" || data.type === "banned") {
                        if (data.t_username === this.userName || data.username === this.userName) {
                            this.isBanned = true;
                            this.isInRoom = false;
                            this.bannedBy = data.from || data.admin || 'Admin';
                            this.banReason = data.reason || 'Banned by admin';
                            this.onLog(`[${this.userName}] üö´ BANNED by ${this.bannedBy}`);
                            this.onBanned(this.bannedBy, this.banReason);
                        }
                    }
                }
            }

            _startPingInterval() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                
                this.pingInterval = setInterval(() => {
                    this.sendPing();
                }, 10000);
            }
            
            sendPing() {
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send("");
                    return true;
                }
                return false;
            }

            login() {
                const payload = {
                    handler: "login",
                    id: this.keyGen(20),
                    username: this.userName,
                    password: this.passWord
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    // Send device info in headers format
                    this.webSocket.send(JSON.stringify(payload));
                }
            }

            requestRoomList() {
                const payload = { handler: "room_list", id: this.keyGen(20) };
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            joinRoom(roomName) {
                if (this.isBanned) {
                    this.onLog(`[${this.userName}] Cannot join - banned from room`);
                    return false;
                }
                
                const payload = { handler: "room_join", id: this.keyGen(20), name: roomName };
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.currentRoom = roomName;
                    this.lastRoom = roomName;
                    return true;
                }
                return false;
            }

            leaveRoom(roomName) {
                const payload = { handler: "room_leave", id: this.keyGen(20), name: roomName || this.currentRoom };
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.isInRoom = false;
                    this.currentRoom = "";
                    this.lastRoom = "";
                    return true;
                }
                return false;
            }

            sendMessage(roomName, message) {
                if (!this.isInRoom || this.isBanned) return false;
                
                const payload = {
                    handler: "room_message",
                    id: this.keyGen(20, true),
                    room: roomName,
                    type: "text",
                    url: "",
                    body: message,
                    length: ""
                };
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            isAlive() {
                return this.webSocket && this.webSocket.readyState === WebSocket.OPEN && this.isConnected;
            }

            keyGen(keyLength, isMsgId = false) {
                let key = "";
                let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                if (isMsgId) {
                    characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ";
                }
                for (let i = 0; i < keyLength; i++) {
                    key += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return key;
            }
        }

        // ==================== MAIN APPLICATION ====================
        
        // State
        let clients = new Map();
        let clientStates = new Map();
        let connectedIdsSet = new Set();
        let activeRoom = '';
        let isInRoom = false;
        let messageLoopInterval = null;
        let isMessageLoopRunning = false;
        let messagesSent = 0;
        let isJoiningSequentially = false;
        let stopJoining = false;
        let idsInRoom = new Set();
        let bannedIds = new Set();
        
        // Background keep-alive
        const keepAlive = new BackgroundKeepAlive();

        // Elements
        const btnEnableBackground = document.getElementById('btnEnableBackground');
        const backgroundStatus = document.getElementById('backgroundStatus');
        const keepAliveStatus = document.getElementById('keepAliveStatus');
        const lastPingTime = document.getElementById('lastPingTime');
        const btnCheckIP = document.getElementById('btnCheckIP');
        const currentIPEl = document.getElementById('currentIP');
        const chkAutoChangeDevice = document.getElementById('chkAutoChangeDevice');
        const joinDelayInput = document.getElementById('joinDelay');

        const inputIds = document.getElementById('inputIds');
        const inputPassword = document.getElementById('inputPassword');
        const btnConnect = document.getElementById('btnConnect');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const connectedCount = document.getElementById('connectedCount');
        const connectedIdsList = document.getElementById('connectedIdsList');
        const delayGroup = document.getElementById('delayGroup');
        const connectionDelay = document.getElementById('connectionDelay');
        const mainIndicator = document.getElementById('mainIndicator');
        const reconnectStatusEl = document.getElementById('reconnectStatus');

        const inputRoom = document.getElementById('inputRoom');
        const roomList = document.getElementById('roomList');
        const btnFetchRooms = document.getElementById('btnFetchRooms');
        const btnJoinRoom = document.getElementById('btnJoinRoom');
        const btnStopJoining = document.getElementById('btnStopJoining');
        const btnLeaveRoom = document.getElementById('btnLeaveRoom');
        const currentRoomStatus = document.getElementById('currentRoomStatus');
        const currentRoomEl = document.getElementById('currentRoom');
        const idsInRoomCountEl = document.getElementById('idsInRoomCount');
        const roomStatus = document.getElementById('roomStatus');
        const joinProgress = document.getElementById('joinProgress');
        const joinProgressList = document.getElementById('joinProgressList');

        const inputMessages = document.getElementById('inputMessages');
        const messageInterval = document.getElementById('messageInterval');
        const btnStartLoop = document.getElementById('btnStartLoop');
        const btnStopLoop = document.getElementById('btnStopLoop');
        const messageStatus = document.getElementById('messageStatus');
        const loopStatusEl = document.getElementById('loopStatus');
        const messagesSentCount = document.getElementById('messagesSentCount');

        const chatBox = document.getElementById('chatBox');
        const logBox = document.getElementById('logBox');
        const btnClearLog = document.getElementById('btnClearLog');
        const btnExportLog = document.getElementById('btnExportLog');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            checkIP();
        });

        function setupEventListeners() {
            btnEnableBackground.addEventListener('click', enableBackgroundMode);
            btnCheckIP.addEventListener('click', checkIP);
            
            document.querySelectorAll('input[name="connectMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    // Always show delay for sequential
                });
            });
            
            btnConnect.addEventListener('click', connectIds);
            btnDisconnect.addEventListener('click', disconnectAll);
            btnFetchRooms.addEventListener('click', fetchRooms);
            
            roomList.addEventListener('change', () => {
                inputRoom.value = roomList.value;
            });
            
            roomList.addEventListener('dblclick', () => {
                if (roomList.value) {
                    inputRoom.value = roomList.value;
                    joinRoomSequentially();
                }
            });
            
            btnJoinRoom.addEventListener('click', joinRoomSequentially);
            btnStopJoining.addEventListener('click', () => {
                stopJoining = true;
                btnStopJoining.classList.add('hidden');
                addLog('Stopping room join process...', 'warning');
            });
            btnLeaveRoom.addEventListener('click', leaveRoom);
            btnStartLoop.addEventListener('click', startMessageLoop);
            btnStopLoop.addEventListener('click', stopMessageLoop);
            
            btnClearLog.addEventListener('click', () => {
                logBox.innerHTML = '<p class="info">Log cleared</p>';
            });
            
            btnExportLog.addEventListener('click', exportLog);
        }

        async function checkIP() {
            currentIPEl.textContent = 'Checking...';
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                currentIPEl.textContent = data.ip;
                addLog(`Current IP: ${data.ip}`, 'info');
            } catch (error) {
                currentIPEl.textContent = 'Could not detect';
                addLog('Could not detect IP address', 'warning');
            }
        }

        function enableBackgroundMode() {
            const success = keepAlive.start(() => {
                const now = new Date().toLocaleTimeString();
                lastPingTime.textContent = `Last ping: ${now}`;
                
                clients.forEach((client) => {
                    if (client.isAlive()) {
                        client.sendPing();
                    }
                });
            });
            
            if (success) {
                btnEnableBackground.textContent = '‚úì Background Mode Enabled';
                btnEnableBackground.disabled = true;
                btnEnableBackground.style.background = '#3a3a5a';
                backgroundStatus.classList.remove('hidden');
                addLog('Background mode enabled', 'success');
            } else {
                addLog('Failed to enable background mode', 'error');
            }
        }

        function createClient(username, password) {
            return new Promise((resolve) => {
                const deviceInfo = DeviceGenerator.generate();
                
                const timeout = setTimeout(() => {
                    clientStates.set(username, 'failed');
                    updateIdTagState(username, 'failed');
                    resolve({ username, success: false, message: 'Connection timeout' });
                }, 20000);

                const callbacks = {
                    onLoginSuccess: () => {
                        clearTimeout(timeout);
                        connectedIdsSet.add(username);
                        clientStates.set(username, 'connected');
                        updateIdTagState(username, 'connected', deviceInfo.deviceId);
                        updateConnectionUI();
                        resolve({ username, success: true, message: 'Connected', deviceId: deviceInfo.deviceId });
                    },
                    onLoginFailed: (error) => {
                        clearTimeout(timeout);
                        clientStates.set(username, 'failed');
                        updateIdTagState(username, 'failed');
                        resolve({ username, success: false, message: error });
                    },
                    onDisconnect: (willReconnect) => {
                        if (willReconnect && !clients.get(username)?.isBanned) {
                            clientStates.set(username, 'reconnecting');
                            updateIdTagState(username, 'reconnecting');
                        } else if (!willReconnect) {
                            connectedIdsSet.delete(username);
                            idsInRoom.delete(username);
                            clientStates.delete(username);
                            updateConnectionUI();
                            updateRoomCount();
                        }
                    },
                    onMessage: (from, message, room) => {
                        addChatMessage(from, message, room);
                    },
                    onRoomJoined: (room) => {
                        idsInRoom.add(username);
                        updateIdTagState(username, 'in-room', clients.get(username)?.deviceInfo?.deviceId);
                        updateRoomCount();
                        isInRoom = true;
                        activeRoom = room;
                        updateRoomStatusUI();
                    },
                    onRoomLeft: (room) => {
                        idsInRoom.delete(username);
                        updateIdTagState(username, 'connected', clients.get(username)?.deviceInfo?.deviceId);
                        updateRoomCount();
                    },
                    onRoomList: (rooms) => {
                        updateRoomListUI(rooms);
                    },
                    onLog: (msg) => {
                        addLog(msg);
                    },
                    onReconnecting: (attempt, delay) => {
                        clientStates.set(username, 'reconnecting');
                        updateIdTagState(username, 'reconnecting', null, attempt);
                    },
                    onReconnected: (room) => {
                        clientStates.set(username, 'connected');
                        connectedIdsSet.add(username);
                        updateConnectionUI();
                        updateIdTagState(username, 'connected');
                        addLog(`[${username}] Reconnected!`, 'success');
                    },
                    onBanned: (bannedBy, reason) => {
                        bannedIds.add(username);
                        idsInRoom.delete(username);
                        clientStates.set(username, 'banned');
                        updateIdTagState(username, 'banned');
                        updateRoomCount();
                        addLog(`üö´ [${username}] BANNED by ${bannedBy}: ${reason}`, 'ban');
                    },
                    onKicked: (kickedBy, reason) => {
                        idsInRoom.delete(username);
                        updateIdTagState(username, 'connected', clients.get(username)?.deviceInfo?.deviceId);
                        updateRoomCount();
                        addLog(`üë¢ [${username}] KICKED by ${kickedBy}: ${reason}`, 'warning');
                    },
                    onRoomEvent: (user, data) => {
                        // Log all room events
                        const eventType = data.type || 'unknown';
                        let eventDetails = '';
                        
                        switch(eventType) {
                            case 'user_joined':
                                eventDetails = `User ${data.username} joined (role: ${data.role || 'member'})`;
                                break;
                            case 'user_left':
                                eventDetails = `User ${data.username} left`;
                                break;
                            case 'banned':
                            case 'ban':
                                eventDetails = `${data.username || 'Someone'} was banned by ${data.by || data.admin || 'admin'}`;
                                break;
                            case 'kicked':
                            case 'kick':
                                eventDetails = `${data.username || 'Someone'} was kicked by ${data.by || data.admin || 'admin'}`;
                                break;
                            case 'role_changed':
                                eventDetails = `${data.username}'s role changed to ${data.role}`;
                                break;
                            default:
                                if (eventType !== 'text' && eventType !== 'join_success' && eventType !== 'joined') {
                                    eventDetails = `Event: ${eventType} - ${JSON.stringify(data)}`;
                                }
                        }
                        
                        if (eventDetails) {
                            addLog(`[ROOM EVENT] ${eventDetails}`, 'event');
                        }
                    }
                };

                const client = new ChatClient(username, password, callbacks, deviceInfo);
                clients.set(username, client);
                clientStates.set(username, 'connecting');
            });
        }

        function updateIdTagState(username, state, deviceId = null, retryCount = 0) {
            const tag = document.getElementById(`tag-${username}`);
            if (tag) {
                tag.className = 'connected-id-tag';
                let content = username;
                
                const client = clients.get(username);
                const devId = deviceId || client?.deviceInfo?.deviceId || '';
                const shortDevId = devId ? devId.substring(0, 15) + '...' : '';
                
                if (state === 'connecting') {
                    tag.classList.add('connecting');
                    content = `‚è≥ ${username}`;
                } else if (state === 'reconnecting') {
                    tag.classList.add('reconnecting');
                    content = `<span class="reconnecting-icon">üîÑ</span> ${username}`;
                    if (retryCount > 0) {
                        content += ` <span class="retry-badge">retry ${retryCount}</span>`;
                    }
                } else if (state === 'failed') {
                    tag.classList.add('failed');
                    content = `‚ùå ${username}`;
                } else if (state === 'banned') {
                    tag.classList.add('banned');
                    content = `üö´ ${username}`;
                } else if (state === 'in-room') {
                    tag.classList.add('in-room');
                    content = `‚úì ${username} <span class="device-id-display">[${shortDevId}]</span>`;
                } else if (state === 'connected') {
                    content = `‚úì ${username} <span class="device-id-display">[${shortDevId}]</span>`;
                }
                
                tag.innerHTML = content;
            }
        }

        function updateRoomCount() {
            idsInRoomCountEl.textContent = idsInRoom.size;
        }

        async function connectIds() {
            const idsText = inputIds.value.trim();
            const password = inputPassword.value.trim();
            
            if (!idsText) {
                addLog('Please enter at least one ID', 'error');
                return;
            }
            
            if (!password) {
                addLog('Please enter password', 'error');
                return;
            }
            
            const ids = idsText.split('#').map(id => id.trim()).filter(id => id);
            
            if (ids.length === 0) {
                addLog('No valid IDs found', 'error');
                return;
            }
            
            if (ids.length > 20) {
                addLog('Maximum 20 IDs allowed', 'error');
                return;
            }
            
            if (!keepAlive.isActive) {
                enableBackgroundMode();
            }
            
            const mode = document.querySelector('input[name="connectMode"]:checked').value;
            const delay = parseInt(connectionDelay.value) || 2000;
            
            btnConnect.disabled = true;
            btnConnect.textContent = 'Connecting...';
            
            connectedIdsList.innerHTML = '';
            ids.forEach(id => {
                const tag = document.createElement('span');
                tag.className = 'connected-id-tag connecting';
                tag.id = `tag-${id}`;
                tag.innerHTML = `‚è≥ ${id}`;
                connectedIdsList.appendChild(tag);
                clientStates.set(id, 'connecting');
            });
            
            addLog(`Connecting ${ids.length} IDs (${mode === 'all' ? 'all at once' : 'one by one'})...`, 'info');
            
            try {
                if (mode === 'all') {
                    const promises = ids.map(id => {
                        if (clients.has(id) && clients.get(id).isAlive()) {
                            return Promise.resolve({ username: id, success: true, message: 'Already connected' });
                        }
                        return createClient(id, password);
                    });
                    await Promise.all(promises);
                } else {
                    for (const id of ids) {
                        if (clients.has(id) && clients.get(id).isAlive()) {
                            updateIdTagState(id, 'connected', clients.get(id).deviceInfo.deviceId);
                            continue;
                        }
                        
                        const result = await createClient(id, password);
                        addLog(`[${id}] ${result.success ? 'Connected' : 'Failed'} (Device: ${result.deviceId || 'N/A'})`, result.success ? 'success' : 'error');
                        
                        if (delay > 0) {
                            await new Promise(r => setTimeout(r, delay));
                        }
                    }
                }
                
                addLog(`Connection complete. Connected: ${connectedIdsSet.size}`, 'success');
                
                if (connectedIdsSet.size > 0) {
                    btnDisconnect.disabled = false;
                    btnFetchRooms.disabled = false;
                    btnJoinRoom.disabled = false;
                }
                
            } catch (error) {
                addLog(`Connection error: ${error.message}`, 'error');
            }
            
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect';
        }

        function updateConnectionUI() {
            const connected = connectedIdsSet.size;
            connectedCount.textContent = connected;
            
            mainIndicator.className = 'connection-indicator';
            if (connected > 0) {
                mainIndicator.classList.add('connected');
                btnDisconnect.disabled = false;
                btnFetchRooms.disabled = false;
                btnJoinRoom.disabled = false;
            } else {
                mainIndicator.classList.add('disconnected');
                btnDisconnect.disabled = true;
                btnFetchRooms.disabled = true;
                btnJoinRoom.disabled = true;
                btnLeaveRoom.disabled = true;
            }
        }

        function disconnectAll() {
            stopMessageLoop();
            stopJoining = true;
            
            clients.forEach((client) => {
                client.disconnect();
            });
            clients.clear();
            clientStates.clear();
            connectedIdsSet.clear();
            idsInRoom.clear();
            bannedIds.clear();
            
            activeRoom = '';
            isInRoom = false;
            messagesSent = 0;
            
            btnDisconnect.disabled = true;
            btnFetchRooms.disabled = true;
            btnJoinRoom.disabled = true;
            btnLeaveRoom.disabled = true;
            currentRoomStatus.classList.add('hidden');
            messageStatus.classList.add('hidden');
            joinProgress.classList.add('hidden');
            
            connectedCount.textContent = '0';
            connectedIdsList.innerHTML = '';
            reconnectStatusEl.textContent = '';
            roomList.innerHTML = '<option value="" disabled>-- Click "Fetch Rooms" to load --</option>';
            
            mainIndicator.className = 'connection-indicator disconnected';
            
            addLog('All IDs disconnected', 'info');
        }

        function fetchRooms() {
            if (connectedIdsSet.size === 0) {
                addLog('Connect IDs first to fetch rooms', 'error');
                return;
            }
            
            btnFetchRooms.disabled = true;
            btnFetchRooms.textContent = 'Fetching...';
            
            let found = false;
            clients.forEach((client) => {
                if (client.isAlive() && !found) {
                    client.requestRoomList();
                    found = true;
                }
            });
            
            if (found) {
                addLog('Fetching room list...', 'info');
            } else {
                addLog('No connected clients available', 'error');
            }
            
            setTimeout(() => {
                btnFetchRooms.disabled = false;
                btnFetchRooms.textContent = 'Fetch Rooms';
            }, 2000);
        }

        function updateRoomListUI(rooms) {
            roomList.innerHTML = '';
            
            if (rooms && rooms.length > 0) {
                rooms.forEach(room => {
                    const option = document.createElement('option');
                    const roomName = typeof room === 'string' ? room : (room.name || room.room || room);
                    option.value = roomName;
                    option.textContent = roomName;
                    roomList.appendChild(option);
                });
                addLog(`Loaded ${rooms.length} rooms`, 'success');
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.disabled = true;
                option.textContent = '-- No rooms found --';
                roomList.appendChild(option);
            }
        }

        async function joinRoomSequentially() {
            const roomName = inputRoom.value.trim();
            
            if (!roomName) {
                addLog('Please enter or select a room name', 'error');
                return;
            }
            
            if (connectedIdsSet.size === 0) {
                addLog('No IDs connected', 'error');
                return;
            }
            
            if (isJoiningSequentially) {
                addLog('Already joining rooms...', 'warning');
                return;
            }
            
            isJoiningSequentially = true;
            stopJoining = false;
            
            btnJoinRoom.disabled = true;
            btnJoinRoom.textContent = 'Joining...';
            btnStopJoining.classList.remove('hidden');
            btnLeaveRoom.disabled = true;
            
            activeRoom = roomName;
            currentRoomEl.textContent = roomName;
            currentRoomStatus.classList.remove('hidden');
            roomStatus.textContent = 'Joining...';
            roomStatus.style.background = '#ffc107';
            
            joinProgress.classList.remove('hidden');
            joinProgressList.innerHTML = '';
            
            chatBox.innerHTML = '';
            
            const delay = parseInt(joinDelayInput.value) || 5000;
            const clientArray = Array.from(clients.entries());
            
            addLog(`Starting sequential room join: ${roomName} (${clientArray.length} IDs, ${delay}ms delay)`, 'info');
            
            for (let i = 0; i < clientArray.length; i++) {
                if (stopJoining) {
                    addLog('Room join stopped by user', 'warning');
                    break;
                }
                
                const [username, client] = clientArray[i];
                
                // Add progress item
                const progressItem = document.createElement('div');
                progressItem.className = 'join-progress-item';
                progressItem.id = `progress-${username}`;
                progressItem.innerHTML = `
                    <span class="status-icon">‚è≥</span>
                    <span class="username">${username}</span>
                    <span class="device-id">${client.deviceInfo.deviceId}</span>
                    <span class="status-text joining">Joining...</span>
                `;
                joinProgressList.appendChild(progressItem);
                
                if (!client.isAlive()) {
                    updateProgressItem(username, '‚ùå', 'Not connected', 'error');
                    continue;
                }
                
                if (client.isBanned) {
                    // Change device ID if auto-change is enabled
                    if (chkAutoChangeDevice.checked) {
                        const newDevice = client.changeDeviceId();
                        updateProgressItem(username, 'üîÑ', `New Device: ${newDevice.deviceId}`, 'waiting');
                        addLog(`[${username}] Changed device ID due to previous ban`, 'warning');
                        
                        // Need to reconnect with new device ID
                        addLog(`[${username}] Reconnecting with new device ID...`, 'info');
                        // For now, skip banned IDs - full reconnect would require disconnect/connect
                        updateProgressItem(username, 'üö´', 'Banned - Skip', 'banned');
                        continue;
                    } else {
                        updateProgressItem(username, 'üö´', 'Banned', 'banned');
                        continue;
                    }
                }
                
                // Join room
                client.isBanned = false; // Reset ban status for retry
                const joined = client.joinRoom(roomName);
                
                if (!joined) {
                    updateProgressItem(username, '‚ùå', 'Join failed', 'error');
                    continue;
                }
                
                // Wait for join result
                const result = await waitForJoinResult(username, 10000);
                
                if (result.success) {
                    updateProgressItem(username, '‚úì', 'In Room', 'joined');
                } else if (result.banned) {
                    updateProgressItem(username, 'üö´', `Banned: ${result.reason}`, 'banned');
                    
                    // If banned, check if we should change device ID for next ID
                    if (chkAutoChangeDevice.checked && i < clientArray.length - 1) {
                        addLog(`‚ö†Ô∏è IP might be banned. Consider changing VPN/IP before next ID joins.`, 'warning');
                        
                        // Generate new device ID for remaining clients
                        for (let j = i + 1; j < clientArray.length; j++) {
                            const [nextUser, nextClient] = clientArray[j];
                            const newDevice = nextClient.changeDeviceId();
                            addLog(`[${nextUser}] Pre-changed device ID to: ${newDevice.deviceId}`, 'info');
                        }
                    }
                } else {
                    updateProgressItem(username, '‚ùå', result.reason || 'Failed', 'error');
                }
                
                // Wait before next join
                if (i < clientArray.length - 1 && !stopJoining) {
                    addLog(`Waiting ${delay}ms before next ID...`, 'info');
                    await new Promise(r => setTimeout(r, delay));
                }
            }
            
            isJoiningSequentially = false;
            stopJoining = false;
            btnJoinRoom.disabled = false;
            btnJoinRoom.textContent = 'Join Room (One by One)';
            btnStopJoining.classList.add('hidden');
            
            if (idsInRoom.size > 0) {
                btnLeaveRoom.disabled = false;
                roomStatus.textContent = 'In Room';
                roomStatus.style.background = '#38ef7d';
                isInRoom = true;
            } else {
                roomStatus.textContent = 'Failed';
                roomStatus.style.background = '#eb3349';
            }
            
            updateRoomCount();
            addLog(`Room join complete. ${idsInRoom.size} IDs in room, ${bannedIds.size} banned`, 'info');
        }

        function updateProgressItem(username, icon, status, statusClass) {
            const item = document.getElementById(`progress-${username}`);
            if (item) {
                item.querySelector('.status-icon').textContent = icon;
                const statusEl = item.querySelector('.status-text');
                statusEl.textContent = status;
                statusEl.className = `status-text ${statusClass}`;
            }
        }

        function waitForJoinResult(username, timeout) {
            return new Promise((resolve) => {
                const client = clients.get(username);
                if (!client) {
                    resolve({ success: false, reason: 'Client not found' });
                    return;
                }
                
                const startTime = Date.now();
                const checkInterval = setInterval(() => {
                    if (client.isInRoom) {
                        clearInterval(checkInterval);
                        resolve({ success: true });
                    } else if (client.isBanned) {
                        clearInterval(checkInterval);
                        resolve({ success: false, banned: true, reason: client.banReason });
                    } else if (Date.now() - startTime > timeout) {
                        clearInterval(checkInterval);
                        resolve({ success: false, reason: 'Timeout' });
                    }
                }, 500);
            });
        }

        function leaveRoom() {
            if (!activeRoom) {
                addLog('Not in any room', 'error');
                return;
            }
            
            stopMessageLoop();
            
            btnLeaveRoom.disabled = true;
            btnLeaveRoom.textContent = 'Leaving...';
            
            clients.forEach((client) => {
                if (client.isAlive() && client.isInRoom) {
                    client.leaveRoom(activeRoom);
                }
            });
            
            idsInRoom.clear();
            isInRoom = false;
            roomStatus.textContent = 'Left';
            roomStatus.style.background = '#eb3349';
            
            addLog(`All IDs left room: ${activeRoom}`, 'info');
            activeRoom = '';
            
            setTimeout(() => {
                currentRoomStatus.classList.add('hidden');
                joinProgress.classList.add('hidden');
            }, 2000);
            
            btnLeaveRoom.disabled = true;
            btnLeaveRoom.textContent = 'Leave Room';
            updateRoomCount();
        }

        function updateRoomStatusUI() {
            if (isInRoom && activeRoom) {
                currentRoomEl.textContent = activeRoom;
                currentRoomStatus.classList.remove('hidden');
                roomStatus.textContent = 'In Room';
                roomStatus.style.background = '#38ef7d';
                btnLeaveRoom.disabled = false;
            }
        }

        function startMessageLoop() {
            const messagesText = inputMessages.value.trim();
            
            if (!messagesText) {
                addLog('Please enter messages to send', 'error');
                return;
            }
            
            if (!activeRoom) {
                addLog('Please join a room first', 'error');
                return;
            }
            
            if (idsInRoom.size === 0) {
                addLog('No IDs in room', 'error');
                return;
            }
            
            const messages = messagesText.split('\n').map(m => m.trim()).filter(m => m);
            
            if (messages.length === 0) {
                addLog('No valid messages found', 'error');
                return;
            }
            
            const interval = Math.max(500, parseInt(messageInterval.value) || 3000);
            
            isMessageLoopRunning = true;
            messagesSent = 0;
            let messageIndex = 0;
            
            const sendNextMessage = () => {
                if (!isMessageLoopRunning) return;
                
                const message = messages[messageIndex % messages.length];
                let count = 0;
                
                clients.forEach((client) => {
                    if (client.isAlive() && client.isInRoom && !client.isBanned) {
                        client.sendMessage(activeRoom, message);
                        count++;
                    }
                });
                
                if (count > 0) {
                    messagesSent++;
                    messagesSentCount.textContent = messagesSent;
                }
                
                messageIndex++;
            };
            
            sendNextMessage();
            messageLoopInterval = setInterval(sendNextMessage, interval);
            
            updateMessageLoopUI();
            addLog(`Started sending ${messages.length} messages (${interval}ms interval)`, 'success');
        }

        function stopMessageLoop() {
            isMessageLoopRunning = false;
            
            if (messageLoopInterval) {
                clearInterval(messageLoopInterval);
                messageLoopInterval = null;
            }
            
            updateMessageLoopUI();
            if (messagesSent > 0) {
                addLog('Message loop stopped', 'info');
            }
        }

        function updateMessageLoopUI() {
            if (isMessageLoopRunning) {
                btnStartLoop.disabled = true;
                btnStopLoop.disabled = false;
                messageStatus.classList.remove('hidden');
                loopStatusEl.textContent = 'Sending...';
                loopStatusEl.classList.add('sending-active');
            } else {
                btnStartLoop.disabled = false;
                btnStopLoop.disabled = true;
                loopStatusEl.textContent = 'Stopped';
                loopStatusEl.classList.remove('sending-active');
            }
        }

        function addChatMessage(from, message, room) {
            const placeholder = chatBox.querySelector('.placeholder-text');
            if (placeholder) placeholder.remove();
            
            const time = new Date().toLocaleTimeString();
            const isOwn = connectedIdsSet.has(from);
            
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
            
            msgDiv.innerHTML = `
                <div class="from">${escapeHtml(from)}</div>
                <div class="text">${escapeHtml(message)}</div>
                <div class="time">${time}</div>
            `;
            
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            while (chatBox.children.length > 100) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }

        function addLog(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const p = document.createElement('p');
            p.className = type;
            p.textContent = `[${time}] ${message}`;
            logBox.appendChild(p);
            logBox.scrollTop = logBox.scrollHeight;
            
            while (logBox.children.length > 500) {
                logBox.removeChild(logBox.firstChild);
            }
        }

        function exportLog() {
            const logs = [];
            logBox.querySelectorAll('p').forEach(p => {
                logs.push(p.textContent);
            });
            
            const blob = new Blob([logs.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-log-${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            addLog('Log exported', 'success');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>