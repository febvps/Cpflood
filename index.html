<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 850px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8rem;
            color: #667eea;
        }

        h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #a0a0ff;
            border-bottom: 1px solid #3a3a5a;
            padding-bottom: 8px;
        }

        .section {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a5a;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 0.9rem;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.95rem;
        }

        input[type="number"] {
            width: 150px;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit;
            line-height: 1.5;
        }

        textarea#inputMessages {
            min-height: 150px;
            font-size: 0.95rem;
        }

        select {
            cursor: pointer;
        }

        select option {
            padding: 8px;
            background: #1a1a2e;
        }

        .hint {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #ccc;
        }

        .radio-label input[type="radio"] {
            width: auto;
            cursor: pointer;
        }

        .room-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .room-list-header label {
            margin-bottom: 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(56, 239, 125, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #ccc;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4a4a6a;
        }

        .status-bar {
            margin-top: 15px;
            padding: 12px 15px;
            background: rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-bar strong {
            color: #38ef7d;
        }

        .room-status {
            background: #38ef7d;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .connected-ids-list {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .connected-id-tag {
            background: rgba(56, 239, 125, 0.2);
            border: 1px solid #38ef7d;
            color: #38ef7d;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .connected-id-tag.connecting {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffc107;
        }

        .connected-id-tag.reconnecting {
            background: rgba(255, 165, 0, 0.2);
            border-color: #ffa500;
            color: #ffa500;
        }

        .connected-id-tag.failed {
            background: rgba(235, 51, 73, 0.2);
            border-color: #eb3349;
            color: #eb3349;
        }

        .retry-badge {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .chat-box {
            height: 250px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #3a3a5a;
        }

        .chat-box .placeholder-text {
            color: #555;
            text-align: center;
            font-style: italic;
        }

        .chat-message {
            padding: 10px 14px;
            margin-bottom: 10px;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .chat-message.own {
            background: rgba(56, 239, 125, 0.1);
            border-left-color: #38ef7d;
        }

        .chat-message .from {
            font-weight: 600;
            color: #667eea;
            font-size: 0.85rem;
        }

        .chat-message.own .from {
            color: #38ef7d;
        }

        .chat-message .text {
            margin-top: 5px;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .chat-message .time {
            font-size: 0.7rem;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .log-box {
            height: 150px;
            overflow-y: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            border: 1px solid #3a3a5a;
        }

        .log-box p {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .log-box .success {
            background: rgba(56, 239, 125, 0.1);
            color: #38ef7d;
        }

        .log-box .error {
            background: rgba(235, 51, 73, 0.1);
            color: #eb3349;
        }

        .log-box .info {
            background: rgba(102, 126, 234, 0.1);
            color: #a0a0ff;
        }

        .log-box .warning {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
        }

        .hidden {
            display: none !important;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sending-active {
            animation: pulse 1s infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .reconnecting-icon {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        .connection-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .connection-indicator.connected {
            background: #38ef7d;
        }

        .connection-indicator.disconnected {
            background: #eb3349;
        }

        .connection-indicator.connecting {
            background: #ffc107;
            animation: pulse 0.5s infinite;
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .button-group {
                flex-direction: column;
            }
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Simple Chat Client</h1>

        <!-- Section 1: Connection -->
        <div class="section">
            <h2>1. Connect IDs</h2>
            <div class="form-group">
                <label>Enter IDs (separated by #, max 20):</label>
                <textarea id="inputIds" placeholder="id1#id2#id3#id4..." rows="3"></textarea>
            </div>
            <div class="form-group">
                <label>Password (same for all IDs):</label>
                <input type="password" id="inputPassword" placeholder="Enter password">
            </div>
            
            <div class="form-group">
                <label>Connection Mode:</label>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="all" checked>
                        <span>Connect All at Once</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="connectMode" value="sequential">
                        <span>Connect One by One</span>
                    </label>
                </div>
            </div>
            
            <div class="form-group hidden" id="delayGroup">
                <label>Delay between connections (ms):</label>
                <input type="number" id="connectionDelay" value="1000" min="100" step="100">
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="autoReconnect" checked>
                    Auto-reconnect if disconnected (retry until connected)
                </label>
            </div>

            <div class="button-group">
                <button id="btnConnect" class="btn btn-primary">Connect</button>
                <button id="btnDisconnect" class="btn btn-danger" disabled>Disconnect All</button>
            </div>
            
            <div class="status-bar">
                <span>
                    <span class="connection-indicator disconnected" id="mainIndicator"></span>
                    Connected: <strong id="connectedCount">0</strong> IDs
                </span>
                <span id="reconnectStatus"></span>
            </div>
            <div id="connectedIdsList" class="connected-ids-list"></div>
        </div>

        <!-- Section 2: Room -->
        <div class="section">
            <h2>2. Room Management</h2>
            
            <div class="form-group">
                <label>Room Name:</label>
                <input type="text" id="inputRoom" placeholder="Enter room name or select from list below">
            </div>
            
            <div class="form-group">
                <div class="room-list-header">
                    <label>Available Rooms:</label>
                    <button id="btnFetchRooms" class="btn btn-small btn-secondary" disabled>Fetch Rooms</button>
                </div>
                <select id="roomList" size="5">
                    <option value="" disabled>-- Click "Fetch Rooms" to load --</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="btnJoinRoom" class="btn btn-primary" disabled>Join Room</button>
                <button id="btnLeaveRoom" class="btn btn-warning" disabled>Leave Room</button>
            </div>
            
            <div id="currentRoomStatus" class="status-bar hidden">
                <span>Current Room: <strong id="currentRoom"></strong></span>
                <span class="room-status" id="roomStatus">In Room</span>
            </div>
        </div>

        <!-- Section 3: Messages -->
        <div class="section">
            <h2>3. Messages</h2>
            
            <div class="form-group">
                <label>Messages to Send (one per line - will loop continuously):</label>
                <textarea id="inputMessages" placeholder="Enter messages here, one per line...&#10;Message 1&#10;Message 2&#10;Message 3&#10;&#10;These will be sent in a loop until you stop." rows="8"></textarea>
            </div>
            
            <div class="form-group">
                <label>Send Interval (ms):</label>
                <input type="number" id="messageInterval" value="3000" min="500" step="500">
                <span class="hint">Minimum 500ms between messages</span>
            </div>
            
            <div class="button-group">
                <button id="btnStartLoop" class="btn btn-success">Start Sending</button>
                <button id="btnStopLoop" class="btn btn-danger" disabled>Stop Sending</button>
            </div>
            
            <div id="messageStatus" class="status-bar hidden">
                <span>Status: <strong id="loopStatus">Sending...</strong></span>
                <span>Messages Sent: <strong id="messagesSentCount">0</strong></span>
            </div>
        </div>

        <!-- Section 4: Chat Display -->
        <div class="section">
            <h2>4. Room Chat</h2>
            <div class="chat-box" id="chatBox">
                <p class="placeholder-text">Join a room to see messages...</p>
            </div>
        </div>

        <!-- Section 5: Log -->
        <div class="section">
            <h2>üìã Activity Log</h2>
            <div class="log-box" id="logBox">
                <p class="info">Application started...</p>
            </div>
            <button id="btnClearLog" class="btn btn-secondary btn-small">Clear Log</button>
        </div>
    </div>

    <script>
        // ==================== CLIENT CLASS WITH AUTO-RECONNECT ====================
        class ChatClient {
            constructor(username, password, callbacks, options = {}) {
                this.URL = 'wss://chatp.net:5333/server';
                this.webSocket = null;
                this.userName = username;
                this.passWord = password;
                this.currentRoom = "";
                this.isConnected = false;
                this.isInRoom = false;
                this.pingInterval = null;
                this.reconnectTimeout = null;
                this.retryCount = 0;
                this.maxRetries = options.maxRetries || Infinity; // Infinite retries by default
                this.autoReconnect = options.autoReconnect !== false; // true by default
                this.baseReconnectDelay = 2000; // Start with 2 seconds
                this.maxReconnectDelay = 30000; // Max 30 seconds
                this.isManualDisconnect = false;
                this.lastRoom = "";
                
                // Callbacks
                this.onLoginSuccess = callbacks.onLoginSuccess || (() => {});
                this.onLoginFailed = callbacks.onLoginFailed || (() => {});
                this.onDisconnect = callbacks.onDisconnect || (() => {});
                this.onMessage = callbacks.onMessage || (() => {});
                this.onRoomJoined = callbacks.onRoomJoined || (() => {});
                this.onRoomLeft = callbacks.onRoomLeft || (() => {});
                this.onRoomList = callbacks.onRoomList || (() => {});
                this.onLog = callbacks.onLog || (() => {});
                this.onReconnecting = callbacks.onReconnecting || (() => {});
                this.onReconnected = callbacks.onReconnected || (() => {});

                this.connect();
            }

            connect() {
                try {
                    // Clear any existing connection
                    if (this.webSocket) {
                        try {
                            this.webSocket.close();
                        } catch(e) {}
                    }

                    this.webSocket = new WebSocket(this.URL);
                    
                    this.webSocket.onopen = () => this._onOpen();
                    this.webSocket.onclose = (e) => this._onClose(e);
                    this.webSocket.onmessage = (e) => this._onMsg(e);
                    this.webSocket.onerror = (e) => this._onError(e);

                } catch (error) {
                    this.onLog(`[${this.userName}] Connection error: ${error.message}`);
                    this._scheduleReconnect();
                }
            }

            disconnect() {
                this.isManualDisconnect = true;
                this.autoReconnect = false;
                this.isConnected = false;
                this.isInRoom = false;
                
                this._clearTimers();

                if (this.webSocket) {
                    try {
                        this.webSocket.close();
                    } catch (e) {}
                    this.webSocket = null;
                }
            }

            _clearTimers() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
            }

            _scheduleReconnect() {
                if (!this.autoReconnect || this.isManualDisconnect) {
                    return;
                }

                if (this.retryCount >= this.maxRetries) {
                    this.onLog(`[${this.userName}] Max retries reached. Giving up.`);
                    this.onLoginFailed('Max retries reached');
                    return;
                }

                // Exponential backoff with jitter
                const delay = Math.min(
                    this.baseReconnectDelay * Math.pow(1.5, this.retryCount) + Math.random() * 1000,
                    this.maxReconnectDelay
                );

                this.retryCount++;
                this.onReconnecting(this.retryCount, delay);
                this.onLog(`[${this.userName}] Reconnecting in ${Math.round(delay/1000)}s (attempt ${this.retryCount})...`);

                this.reconnectTimeout = setTimeout(() => {
                    this.connect();
                }, delay);
            }

            _onOpen() {
                this.onLog(`[${this.userName}] Socket opened, logging in...`);
                this.login();
            }

            _onClose(event) {
                this.onLog(`[${this.userName}] Socket closed (code: ${event.code})`);
                const wasConnected = this.isConnected;
                this.isConnected = false;
                this.isInRoom = false;
                
                this._clearTimers();

                if (!this.isManualDisconnect) {
                    this.onDisconnect(true); // true = will reconnect
                    this._scheduleReconnect();
                } else {
                    this.onDisconnect(false); // false = won't reconnect
                }
            }

            _onError(error) {
                this.onLog(`[${this.userName}] WebSocket error`);
            }

            _onMsg(event) {
                try {
                    const payload = event.data;
                    if (!payload || payload.length === 0) return;
                    
                    const parsedData = JSON.parse(payload);
                    this._handleParsedData(parsedData);
                } catch (error) {
                    // Ignore parse errors
                }
            }

            _handleParsedData(parsedData) {
                if (parsedData.handler === "login_event") {
                    if (parsedData.type === "success") {
                        this.isConnected = true;
                        this.retryCount = 0; // Reset retry count on successful login
                        this._startPingInterval();
                        this.onLog(`[${this.userName}] Login successful`);
                        
                        // If this was a reconnect and we were in a room, rejoin
                        if (this.lastRoom) {
                            this.onLog(`[${this.userName}] Rejoining room: ${this.lastRoom}`);
                            this.joinRoom(this.lastRoom);
                            this.onReconnected(this.lastRoom);
                        } else {
                            this.onLoginSuccess();
                        }
                    } else {
                        this.onLog(`[${this.userName}] Login failed: ${parsedData.reason || parsedData.type}`);
                        // Don't retry on auth failure
                        if (parsedData.reason === 'invalid_password' || parsedData.reason === 'invalid_username') {
                            this.autoReconnect = false;
                            this.onLoginFailed(parsedData.reason || parsedData.type || "Unknown error");
                        } else {
                            this._scheduleReconnect();
                        }
                    }
                }

                if (parsedData.handler === "room_list") {
                    if (parsedData.rooms) {
                        this.onRoomList(parsedData.rooms);
                    }
                }

                if (parsedData.handler === "room_event") {
                    if (parsedData.type === "text") {
                        this.onMessage(parsedData.from, parsedData.body, parsedData.room);
                    }

                    if (parsedData.type === "join_success" || parsedData.type === "joined") {
                        const room = parsedData.name || parsedData.room;
                        this.currentRoom = room;
                        this.lastRoom = room; // Remember for reconnection
                        this.isInRoom = true;
                        this.onLog(`[${this.userName}] Joined room: ${room}`);
                        this.onRoomJoined(room);
                    }

                    if (parsedData.type === "leave_success" || parsedData.type === "left") {
                        const room = parsedData.name || parsedData.room || this.currentRoom;
                        this.currentRoom = "";
                        this.lastRoom = ""; // Clear remembered room
                        this.isInRoom = false;
                        this.onLog(`[${this.userName}] Left room: ${room}`);
                        this.onRoomLeft(room);
                    }
                }
            }

            _startPingInterval() {
                if (this.pingInterval) clearInterval(this.pingInterval);
                
                // Send ping every 20 seconds to keep connection alive
                this.pingInterval = setInterval(() => {
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        this.webSocket.send("");
                    } else if (!this.isManualDisconnect) {
                        // Connection lost, try to reconnect
                        this._clearTimers();
                        this._scheduleReconnect();
                    }
                }, 20000); // 20 seconds - more frequent pings
            }

            login() {
                const payload = {
                    handler: "login",
                    id: this.keyGen(20),
                    username: this.userName,
                    password: this.passWord
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                }
            }

            requestRoomList() {
                const payload = {
                    handler: "room_list",
                    id: this.keyGen(20)
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            joinRoom(roomName) {
                const payload = {
                    handler: "room_join",
                    id: this.keyGen(20),
                    name: roomName
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.currentRoom = roomName;
                    this.lastRoom = roomName; // Remember for reconnection
                    return true;
                }
                return false;
            }

            leaveRoom(roomName) {
                const payload = {
                    handler: "room_leave",
                    id: this.keyGen(20),
                    name: roomName || this.currentRoom
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    this.isInRoom = false;
                    this.currentRoom = "";
                    this.lastRoom = ""; // Clear remembered room
                    return true;
                }
                return false;
            }

            sendMessage(roomName, message) {
                const payload = {
                    handler: "room_message",
                    id: this.keyGen(20, true),
                    room: roomName,
                    type: "text",
                    url: "",
                    body: message,
                    length: ""
                };
                
                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.send(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            keyGen(keyLength, isMsgId = false) {
                let key = "";
                let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                if (isMsgId) {
                    characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ";
                }
                for (let i = 0; i < keyLength; i++) {
                    key += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return key;
            }

            // Check if socket is alive
            isAlive() {
                return this.webSocket && this.webSocket.readyState === WebSocket.OPEN && this.isConnected;
            }
        }

        // ==================== MAIN APPLICATION ====================
        
        // State
        let clients = new Map();
        let clientStates = new Map(); // Track connection states
        let connectedIdsSet = new Set();
        let activeRoom = '';
        let isInRoom = false;
        let messageLoopInterval = null;
        let isMessageLoopRunning = false;
        let messagesSent = 0;
        let storedPassword = '';
        let keepAliveInterval = null;

        // Elements
        const inputIds = document.getElementById('inputIds');
        const inputPassword = document.getElementById('inputPassword');
        const btnConnect = document.getElementById('btnConnect');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const connectedCount = document.getElementById('connectedCount');
        const connectedIdsList = document.getElementById('connectedIdsList');
        const delayGroup = document.getElementById('delayGroup');
        const connectionDelay = document.getElementById('connectionDelay');
        const autoReconnectCheckbox = document.getElementById('autoReconnect');
        const mainIndicator = document.getElementById('mainIndicator');
        const reconnectStatusEl = document.getElementById('reconnectStatus');

        const inputRoom = document.getElementById('inputRoom');
        const roomList = document.getElementById('roomList');
        const btnFetchRooms = document.getElementById('btnFetchRooms');
        const btnJoinRoom = document.getElementById('btnJoinRoom');
        const btnLeaveRoom = document.getElementById('btnLeaveRoom');
        const currentRoomStatus = document.getElementById('currentRoomStatus');
        const currentRoomEl = document.getElementById('currentRoom');
        const roomStatus = document.getElementById('roomStatus');

        const inputMessages = document.getElementById('inputMessages');
        const messageInterval = document.getElementById('messageInterval');
        const btnStartLoop = document.getElementById('btnStartLoop');
        const btnStopLoop = document.getElementById('btnStopLoop');
        const messageStatus = document.getElementById('messageStatus');
        const loopStatusEl = document.getElementById('loopStatus');
        const messagesSentCount = document.getElementById('messagesSentCount');

        const chatBox = document.getElementById('chatBox');
        const logBox = document.getElementById('logBox');
        const btnClearLog = document.getElementById('btnClearLog');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            setupVisibilityHandler();
            startKeepAlive();
        });

        function setupEventListeners() {
            document.querySelectorAll('input[name="connectMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    delayGroup.classList.toggle('hidden', e.target.value !== 'sequential');
                });
            });
            
            btnConnect.addEventListener('click', connectIds);
            btnDisconnect.addEventListener('click', disconnectAll);
            btnFetchRooms.addEventListener('click', fetchRooms);
            
            roomList.addEventListener('change', () => {
                inputRoom.value = roomList.value;
            });
            
            roomList.addEventListener('dblclick', () => {
                if (roomList.value) {
                    inputRoom.value = roomList.value;
                    joinRoom();
                }
            });
            
            btnJoinRoom.addEventListener('click', joinRoom);
            btnLeaveRoom.addEventListener('click', leaveRoom);
            btnStartLoop.addEventListener('click', startMessageLoop);
            btnStopLoop.addEventListener('click', stopMessageLoop);
            
            btnClearLog.addEventListener('click', () => {
                logBox.innerHTML = '<p class="info">Log cleared</p>';
            });
        }

        // Handle page visibility changes
        function setupVisibilityHandler() {
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    addLog('Tab became visible - checking connections...', 'info');
                    checkAndReconnectAll();
                }
            });

            // Also handle window focus
            window.addEventListener('focus', () => {
                checkAndReconnectAll();
            });
        }

        // Keep connections alive
        function startKeepAlive() {
            // Check connections every 30 seconds
            keepAliveInterval = setInterval(() => {
                checkAndReconnectAll();
            }, 30000);
        }

        function checkAndReconnectAll() {
            clients.forEach((client, username) => {
                if (!client.isAlive() && !client.isManualDisconnect && client.autoReconnect) {
                    addLog(`[${username}] Connection check failed, reconnecting...`, 'warning');
                    client.connect();
                }
            });
        }

        function createClient(username, password) {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    resolve({ username, success: false, message: 'Connection timeout' });
                }, 15000);

                const autoReconnect = autoReconnectCheckbox.checked;

                const callbacks = {
                    onLoginSuccess: () => {
                        clearTimeout(timeout);
                        clients.set(username, client);
                        connectedIdsSet.add(username);
                        clientStates.set(username, 'connected');
                        updateConnectionUI();
                        updateIdTagState(username, 'connected');
                        resolve({ username, success: true, message: 'Connected' });
                    },
                    onLoginFailed: (error) => {
                        clearTimeout(timeout);
                        clientStates.set(username, 'failed');
                        updateIdTagState(username, 'failed');
                        resolve({ username, success: false, message: error });
                    },
                    onDisconnect: (willReconnect) => {
                        if (willReconnect) {
                            clientStates.set(username, 'reconnecting');
                            updateIdTagState(username, 'reconnecting');
                        } else {
                            clients.delete(username);
                            connectedIdsSet.delete(username);
                            clientStates.delete(username);
                            updateConnectionUI();
                            addLog(`${username} disconnected`);
                        }
                    },
                    onMessage: (from, message, room) => {
                        addChatMessage(from, message, room);
                    },
                    onRoomJoined: (room) => {
                        isInRoom = true;
                        activeRoom = room;
                        updateRoomStatusUI();
                    },
                    onRoomLeft: (room) => {},
                    onRoomList: (rooms) => {
                        updateRoomListUI(rooms);
                    },
                    onLog: (msg) => {
                        addLog(msg);
                    },
                    onReconnecting: (attempt, delay) => {
                        clientStates.set(username, 'reconnecting');
                        updateIdTagState(username, 'reconnecting', attempt);
                        updateReconnectStatus();
                    },
                    onReconnected: (room) => {
                        clientStates.set(username, 'connected');
                        connectedIdsSet.add(username);
                        updateConnectionUI();
                        updateIdTagState(username, 'connected');
                        addLog(`[${username}] Reconnected successfully!`, 'success');
                        updateReconnectStatus();
                    }
                };

                const options = {
                    autoReconnect: autoReconnect,
                    maxRetries: Infinity // Keep trying forever
                };

                const client = new ChatClient(username, password, callbacks, options);
                clientStates.set(username, 'connecting');
            });
        }

        function updateIdTagState(username, state, retryCount = 0) {
            const tag = document.getElementById(`tag-${username}`);
            if (tag) {
                tag.className = 'connected-id-tag';
                let content = username;
                
                if (state === 'connecting') {
                    tag.classList.add('connecting');
                    content = `‚è≥ ${username}`;
                } else if (state === 'reconnecting') {
                    tag.classList.add('reconnecting');
                    content = `<span class="reconnecting-icon">üîÑ</span> ${username}`;
                    if (retryCount > 0) {
                        content += ` <span class="retry-badge">retry ${retryCount}</span>`;
                    }
                } else if (state === 'failed') {
                    tag.classList.add('failed');
                    content = `‚ùå ${username}`;
                } else if (state === 'connected') {
                    content = `‚úì ${username}`;
                }
                
                tag.innerHTML = content;
            }
        }

        function updateReconnectStatus() {
            const reconnecting = [];
            clientStates.forEach((state, username) => {
                if (state === 'reconnecting') {
                    reconnecting.push(username);
                }
            });
            
            if (reconnecting.length > 0) {
                reconnectStatusEl.innerHTML = `<span class="reconnecting-icon">üîÑ</span> Reconnecting ${reconnecting.length} ID(s)...`;
            } else {
                reconnectStatusEl.textContent = '';
            }
        }

        async function connectIds() {
            const idsText = inputIds.value.trim();
            const password = inputPassword.value.trim();
            
            if (!idsText) {
                addLog('Please enter at least one ID', 'error');
                return;
            }
            
            if (!password) {
                addLog('Please enter password', 'error');
                return;
            }
            
            // Store password for potential reconnections
            storedPassword = password;
            
            const ids = idsText.split('#').map(id => id.trim()).filter(id => id);
            
            if (ids.length === 0) {
                addLog('No valid IDs found', 'error');
                return;
            }
            
            if (ids.length > 20) {
                addLog('Maximum 20 IDs allowed', 'error');
                return;
            }
            
            const mode = document.querySelector('input[name="connectMode"]:checked').value;
            const delay = parseInt(connectionDelay.value) || 1000;
            
            btnConnect.disabled = true;
            btnConnect.textContent = 'Connecting...';
            
            connectedIdsList.innerHTML = '';
            ids.forEach(id => {
                const tag = document.createElement('span');
                tag.className = 'connected-id-tag connecting';
                tag.id = `tag-${id}`;
                tag.innerHTML = `‚è≥ ${id}`;
                connectedIdsList.appendChild(tag);
                clientStates.set(id, 'connecting');
            });
            
            addLog(`Connecting ${ids.length} IDs (${mode === 'all' ? 'all at once' : 'one by one'})...`, 'info');
            
            try {
                if (mode === 'all') {
                    const promises = ids.map(id => {
                        if (clients.has(id)) {
                            return Promise.resolve({ username: id, success: true, message: 'Already connected' });
                        }
                        return createClient(id, password);
                    });
                    const results = await Promise.all(promises);
                    
                    const successful = results.filter(r => r.success).length;
                    const failed = results.filter(r => !r.success).length;
                    addLog(`Connected: ${successful}, Failed: ${failed}`, successful > 0 ? 'success' : 'error');
                } else {
                    for (const id of ids) {
                        if (clients.has(id) && clients.get(id).isAlive()) {
                            updateIdTagState(id, 'connected');
                            continue;
                        }
                        
                        const result = await createClient(id, password);
                        
                        if (delay > 0 && !result.success) {
                            await new Promise(r => setTimeout(r, delay));
                        } else if (delay > 0) {
                            await new Promise(r => setTimeout(r, delay));
                        }
                    }
                    
                    addLog(`Finished connecting. Total connected: ${connectedIdsSet.size}`, 'success');
                }
                
                if (connectedIdsSet.size > 0) {
                    btnDisconnect.disabled = false;
                    btnFetchRooms.disabled = false;
                    btnJoinRoom.disabled = false;
                }
                
            } catch (error) {
                addLog(`Connection error: ${error.message}`, 'error');
            }
            
            btnConnect.disabled = false;
            btnConnect.textContent = 'Connect';
        }

        function updateConnectionUI() {
            const connected = connectedIdsSet.size;
            connectedCount.textContent = connected;
            
            // Update main indicator
            mainIndicator.className = 'connection-indicator';
            if (connected > 0) {
                mainIndicator.classList.add('connected');
            } else {
                mainIndicator.classList.add('disconnected');
            }
            
            if (connected === 0) {
                btnDisconnect.disabled = true;
                btnFetchRooms.disabled = true;
                btnJoinRoom.disabled = true;
                btnLeaveRoom.disabled = true;
            }
        }

        function disconnectAll() {
            stopMessageLoop();
            
            // Stop keep alive check
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
            }
            
            clients.forEach((client) => {
                client.disconnect();
            });
            clients.clear();
            clientStates.clear();
            connectedIdsSet.clear();
            
            activeRoom = '';
            isInRoom = false;
            messagesSent = 0;
            storedPassword = '';
            
            btnDisconnect.disabled = true;
            btnFetchRooms.disabled = true;
            btnJoinRoom.disabled = true;
            btnLeaveRoom.disabled = true;
            currentRoomStatus.classList.add('hidden');
            messageStatus.classList.add('hidden');
            
            connectedCount.textContent = '0';
            connectedIdsList.innerHTML = '';
            reconnectStatusEl.textContent = '';
            roomList.innerHTML = '<option value="" disabled>-- Click "Fetch Rooms" to load --</option>';
            
            mainIndicator.className = 'connection-indicator disconnected';
            
            addLog('All IDs disconnected', 'info');
            
            // Restart keep alive
            startKeepAlive();
        }

        function fetchRooms() {
            if (connectedIdsSet.size === 0) {
                addLog('Connect IDs first to fetch rooms', 'error');
                return;
            }
            
            btnFetchRooms.disabled = true;
            btnFetchRooms.textContent = 'Fetching...';
            
            // Find a connected client
            let foundClient = null;
            clients.forEach((client) => {
                if (client.isAlive() && !foundClient) {
                    foundClient = client;
                }
            });
            
            if (foundClient) {
                foundClient.requestRoomList();
                addLog('Fetching room list...', 'info');
            } else {
                addLog('No connected clients available', 'error');
            }
            
            setTimeout(() => {
                btnFetchRooms.disabled = false;
                btnFetchRooms.textContent = 'Fetch Rooms';
            }, 2000);
        }

        function updateRoomListUI(rooms) {
            roomList.innerHTML = '';
            
            if (rooms && rooms.length > 0) {
                rooms.forEach(room => {
                    const option = document.createElement('option');
                    const roomName = typeof room === 'string' ? room : (room.name || room.room || room);
                    option.value = roomName;
                    option.textContent = roomName;
                    roomList.appendChild(option);
                });
                addLog(`Loaded ${rooms.length} rooms`, 'success');
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.disabled = true;
                option.textContent = '-- No rooms found --';
                roomList.appendChild(option);
            }
        }

        function joinRoom() {
            const roomName = inputRoom.value.trim();
            
            if (!roomName) {
                addLog('Please enter or select a room name', 'error');
                return;
            }
            
            if (connectedIdsSet.size === 0) {
                addLog('No IDs connected', 'error');
                return;
            }
            
            btnJoinRoom.disabled = true;
            btnJoinRoom.textContent = 'Joining...';
            
            let joinCount = 0;
            clients.forEach((client) => {
                if (client.isAlive()) {
                    client.joinRoom(roomName);
                    joinCount++;
                }
            });
            
            activeRoom = roomName;
            isInRoom = true;
            
            currentRoomEl.textContent = roomName;
            currentRoomStatus.classList.remove('hidden');
            roomStatus.textContent = 'In Room';
            roomStatus.style.background = '#38ef7d';
            
            btnLeaveRoom.disabled = false;
            chatBox.innerHTML = '';
            
            addLog(`${joinCount} IDs joining room: ${roomName}`, 'success');
            
            btnJoinRoom.disabled = false;
            btnJoinRoom.textContent = 'Join Room';
        }

        function leaveRoom() {
            if (!activeRoom) {
                addLog('Not in any room', 'error');
                return;
            }
            
            stopMessageLoop();
            
            btnLeaveRoom.disabled = true;
            btnLeaveRoom.textContent = 'Leaving...';
            
            clients.forEach((client) => {
                if (client.isAlive()) {
                    client.leaveRoom(activeRoom);
                }
            });
            
            isInRoom = false;
            roomStatus.textContent = 'Left';
            roomStatus.style.background = '#eb3349';
            
            addLog(`All IDs left room: ${activeRoom}`, 'info');
            activeRoom = '';
            
            setTimeout(() => {
                currentRoomStatus.classList.add('hidden');
            }, 2000);
            
            btnLeaveRoom.disabled = true;
            btnLeaveRoom.textContent = 'Leave Room';
        }

        function updateRoomStatusUI() {
            if (isInRoom && activeRoom) {
                currentRoomEl.textContent = activeRoom;
                currentRoomStatus.classList.remove('hidden');
                roomStatus.textContent = 'In Room';
                roomStatus.style.background = '#38ef7d';
                btnLeaveRoom.disabled = false;
            }
        }

        function startMessageLoop() {
            const messagesText = inputMessages.value.trim();
            
            if (!messagesText) {
                addLog('Please enter messages to send', 'error');
                return;
            }
            
            if (!activeRoom) {
                addLog('Please join a room first', 'error');
                return;
            }
            
            if (!isInRoom) {
                addLog('Not in a room. Please join a room first.', 'error');
                return;
            }
            
            const messages = messagesText.split('\n').map(m => m.trim()).filter(m => m);
            
            if (messages.length === 0) {
                addLog('No valid messages found', 'error');
                return;
            }
            
            const interval = Math.max(500, parseInt(messageInterval.value) || 3000);
            
            isMessageLoopRunning = true;
            messagesSent = 0;
            let messageIndex = 0;
            
            const sendNextMessage = () => {
                if (!isMessageLoopRunning) return;
                
                const message = messages[messageIndex % messages.length];
                let count = 0;
                
                clients.forEach((client) => {
                    if (client.isAlive() && (client.isInRoom || client.currentRoom === activeRoom)) {
                        client.sendMessage(activeRoom, message);
                        count++;
                    }
                });
                
                if (count > 0) {
                    messagesSent++;
                    messagesSentCount.textContent = messagesSent;
                }
                
                messageIndex++;
            };
            
            sendNextMessage();
            messageLoopInterval = setInterval(sendNextMessage, interval);
            
            updateMessageLoopUI();
            addLog(`Started sending ${messages.length} messages with ${interval}ms interval`, 'success');
        }

        function stopMessageLoop() {
            isMessageLoopRunning = false;
            
            if (messageLoopInterval) {
                clearInterval(messageLoopInterval);
                messageLoopInterval = null;
            }
            
            updateMessageLoopUI();
            if (messagesSent > 0) {
                addLog('Message loop stopped', 'info');
            }
        }

        function updateMessageLoopUI() {
            if (isMessageLoopRunning) {
                btnStartLoop.disabled = true;
                btnStopLoop.disabled = false;
                messageStatus.classList.remove('hidden');
                loopStatusEl.textContent = 'Sending...';
                loopStatusEl.classList.add('sending-active');
            } else {
                btnStartLoop.disabled = false;
                btnStopLoop.disabled = true;
                loopStatusEl.textContent = 'Stopped';
                loopStatusEl.classList.remove('sending-active');
            }
        }

        function addChatMessage(from, message, room) {
            const placeholder = chatBox.querySelector('.placeholder-text');
            if (placeholder) placeholder.remove();
            
            const time = new Date().toLocaleTimeString();
            const isOwn = connectedIdsSet.has(from);
            
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${isOwn ? 'own' : ''}`;
            
            msgDiv.innerHTML = `
                <div class="from">${escapeHtml(from)}</div>
                <div class="text">${escapeHtml(message)}</div>
                <div class="time">${time}</div>
            `;
            
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            while (chatBox.children.length > 100) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }

        function addLog(message, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const p = document.createElement('p');
            p.className = type;
            p.textContent = `[${time}] ${message}`;
            logBox.appendChild(p);
            logBox.scrollTop = logBox.scrollHeight;
            
            while (logBox.children.length > 200) {
                logBox.removeChild(logBox.firstChild);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>